<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="V-ISLAND">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://vonxxghost.xyz/img/home-bg.jpg">
    <meta property="twitter:image" content="https://vonxxghost.xyz/img/home-bg.jpg" />
    

    
    <meta name="title" content="Cassandra CQL3文档" />
    <meta property="og:title" content="Cassandra CQL3文档" />
    <meta property="twitter:title" content="Cassandra CQL3文档" />
    

    
    <meta name="description" content="VonXXGhostのつぶやき">
    <meta property="og:description" content="VonXXGhostのつぶやき" />
    <meta property="twitter:description" content="VonXXGhostのつぶやき" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Cassandra CQL3文档 | VonXXGhost Blog</title>

    <link rel="canonical" href="/post/2021-01-14-cassandra-cql3%E6%96%87%E6%A1%A3/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">V-ISLAND</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                    
		    
                        <li><a href="/top/works/">WORKS</a></li>
                    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/home-bg.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/%E6%8A%80%E6%9C%AF" title="技术">
                            技术
                        </a>
                        
                        <a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93" title="数据库">
                            数据库
                        </a>
                        
                    </div>
                    <h1>Cassandra CQL3文档</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    V-ISLAND
                             
                            on 
                            Thursday, January 14, 2021
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <p>摘抄翻译自<a href="https://cassandra.apache.org/doc/old/CQL-3.0.html">官网文档</a>。部分为机翻润色。</p>
<h2 id="cql-语法">CQL 语法</h2>
<h3 id="约定">约定</h3>
<p>本文档的语言规则描述使用以下这种 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> 式的标注：</p>
<pre tabindex="0"><code>&lt;start&gt; ::= TERMINAL &lt;non-terminal1&gt; &lt;non-terminal1&gt;
</code></pre><ul>
<li>非终止符将具有&lt;尖括号&gt;。</li>
<li>作为 BNF 的附加快捷符号，我们将使用传统正则表达式的（<code>?</code>, <code>+</code> 和 <code>*</code>）表示给定符号是可选的或者是可重复。我们还将允许括号对符号进行分组， <code>[&lt;characters&gt;]</code>  表示  <code>&lt;characters&gt;</code> 中的任意一个。</li>
</ul>
<h3 id="标识符与关键词">标识符与关键词</h3>
<ul>
<li>对于没被双引号括住的词汇，CQL 对大小写不区分，反之区分。</li>
<li>标识符的正则是<code>[a-zA-Z][a-zA-Z0-9_]*</code>，但对于被括住的词汇没有限制。同时，如果在被括住的词汇中出现了某些特殊名称，可能会造成工作异常，应尽量避免。一般来说，不加引号的标识符应该是首选的。如果使用加引号的标识符，强烈建议避免使用方括号括起来的名称（如<code>&quot;[applied]&quot;</code>）和任何看起来像函数调用的名称（如<code>&quot;f(x)&quot;</code>）。</li>
</ul>
<h3 id="常量">常量</h3>
<ul>
<li>字符串：使用单引号括住。注意与双引号标识符进行区分。</li>
<li>整型：<code>'-'?[0-9]+</code></li>
<li>浮点型：<code>'-'?[0-9]+('.'[0-9]*)?([eE][+-]?[0-9+])?</code>。此外 <code>NaN</code> 和 <code>Infinity</code> 也是浮点型常量。</li>
<li>布尔型： <code>true</code> or <code>false</code> ，不区分大小写</li>
<li>UUID：<code>hex{8}-hex{4}-hex{4}-hex{4}-hex{12}</code></li>
<li>blob型：<code>0[xX](hex)+</code></li>
</ul>
<h3 id="语句">语句</h3>
<p>以下为后文将会使用的非终止符定义：</p>
<pre tabindex="0"><code>&lt;identifier&gt; ::= any quoted or unquoted identifier, excluding reserved keywords
 &lt;tablename&gt; ::= (&lt;identifier&gt; &#39;.&#39;)? &lt;identifier&gt;

    &lt;string&gt; ::= a string constant
   &lt;integer&gt; ::= an integer constant
     &lt;float&gt; ::= a float constant
    &lt;number&gt; ::= &lt;integer&gt; | &lt;float&gt;
      &lt;uuid&gt; ::= a uuid constant
   &lt;boolean&gt; ::= a boolean constant
       &lt;hex&gt; ::= a blob constant

  &lt;constant&gt; ::= &lt;string&gt;
               | &lt;number&gt;
               | &lt;uuid&gt;
               | &lt;boolean&gt;
               | &lt;hex&gt;
  &lt;variable&gt; ::= &#39;?&#39;    // 匿名变量
               | &#39;:&#39; &lt;identifier&gt;    // 命名变量
      &lt;term&gt; ::= &lt;constant&gt;
               | &lt;collection-literal&gt;
               | &lt;variable&gt;
               | &lt;function&gt; &#39;(&#39; (&lt;term&gt; (&#39;,&#39; &lt;term&gt;)*)? &#39;)&#39;

  &lt;collection-literal&gt; ::= &lt;map-literal&gt;
                         | &lt;set-literal&gt;
                         | &lt;list-literal&gt;
         &lt;map-literal&gt; ::= &#39;{&#39; ( &lt;term&gt; &#39;:&#39; &lt;term&gt; ( &#39;,&#39; &lt;term&gt; &#39;:&#39; &lt;term&gt; )* )? &#39;}&#39;
         &lt;set-literal&gt; ::= &#39;{&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt; )* )? &#39;}&#39;
        &lt;list-literal&gt; ::= &#39;[&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt; )* )? &#39;]&#39;

    &lt;function&gt; ::= &lt;ident&gt;

  &lt;properties&gt; ::= &lt;property&gt; (AND &lt;property&gt;)*
    &lt;property&gt; ::= &lt;identifier&gt; &#39;=&#39; ( &lt;identifier&gt; | &lt;constant&gt; | &lt;map-literal&gt; )
</code></pre><p>对于字符串语句，有两种语法：一是单引号括起来，二是使用双美元符号括起来。后者允许字符串内包括单引号，一般使用场景是在函数中使用。例子：</p>
<pre tabindex="0"><code>  &#39;some string value&#39;

  $$double-dollar string can contain single &#39; quotes$$
</code></pre><h2 id="数据定义">数据定义</h2>
<h3 id="create-keyspace-创建键空间">CREATE KEYSPACE 创建键空间</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-keyspace-stmt&gt; ::= CREATE KEYSPACE (IF NOT EXISTS)? &lt;identifier&gt; WITH &lt;properties
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">KEYSPACE</span> Excelsior
</span></span><span style="display:flex;"><span>           <span style="color:#ff79c6">WITH</span> <span style="color:#ff79c6">replication</span> <span style="color:#ff79c6">=</span> {<span style="color:#f1fa8c">&#39;class&#39;</span>: <span style="color:#f1fa8c">&#39;SimpleStrategy&#39;</span>, <span style="color:#f1fa8c">&#39;replication_factor&#39;</span> : <span style="color:#bd93f9">3</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">KEYSPACE</span> Excalibur
</span></span><span style="display:flex;"><span>           <span style="color:#ff79c6">WITH</span> <span style="color:#ff79c6">replication</span> <span style="color:#ff79c6">=</span> {<span style="color:#f1fa8c">&#39;class&#39;</span>: <span style="color:#f1fa8c">&#39;NetworkTopologyStrategy&#39;</span>, <span style="color:#f1fa8c">&#39;DC1&#39;</span> : <span style="color:#bd93f9">1</span>, <span style="color:#f1fa8c">&#39;DC2&#39;</span> : <span style="color:#bd93f9">3</span>}
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">AND</span> <span style="color:#ff79c6">durable_writes</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span>;
</span></span></code></pre></div><p>顶级的键空间，可以理解为RDB中的“库”，定义了一个副本策略（<em>replication strategy</em>）和一些表的配置。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>kind</th>
<th>必需</th>
<th>default</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>replication</code></td>
<td><em>map</em></td>
<td>yes</td>
<td></td>
<td>键空间的副本策略和选项</td>
</tr>
<tr>
<td><code>durable_writes</code></td>
<td><em>simple</em></td>
<td>no</td>
<td>true</td>
<td>是否对该键空间上的更新使用commit日志</td>
</tr>
</tbody>
</table>
<p><code>replication</code> 参数至少必须包含一个 <code>class</code> 子选项，定义要使用的副本策略。Cassandra 默认支持以下几种：</p>
<ul>
<li><code>'SimpleStrategy'</code>: 只定义整个集群的复制系数（<em>replication factor</em>）的简单策略。其唯一且必需的参数只有 <code>'replication_factor'</code> ，定义了复制系数的大小。</li>
<li><code>'NetworkTopologyStrategy'</code>: 允许给各个数据中心设置不同的复制系数。</li>
<li><code>'OldNetworkTopologyStrategy'</code>: 旧的副本策略，应避免使用，并使用 <code>'NetworkTopologyStrategy' </code> 代替。</li>
</ul>
<h3 id="use-指定键空间">USE 指定键空间</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;use-stmt&gt; ::= USE &lt;identifier&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">USE</span> myApp;
</span></span></code></pre></div><h3 id="alter-keyspace-修改键空间">ALTER KEYSPACE 修改键空间</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-keyspace-stmt&gt; ::= ALTER KEYSPACE &lt;identifier&gt; WITH &lt;properties&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">KEYSPACE</span> Excelsior
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">WITH</span> <span style="color:#ff79c6">replication</span> <span style="color:#ff79c6">=</span> {<span style="color:#f1fa8c">&#39;class&#39;</span>: <span style="color:#f1fa8c">&#39;SimpleStrategy&#39;</span>, <span style="color:#f1fa8c">&#39;replication_factor&#39;</span> : <span style="color:#bd93f9">4</span>};
</span></span></code></pre></div><p>支持的 <code>&lt;properties&gt;</code> 与 <code>CREATE KEYSPACE</code> 相同。</p>
<h3 id="drop-keyspace-删除键空间">DROP KEYSPACE 删除键空间</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-keyspace-stmt&gt; ::= DROP KEYSPACE ( IF EXISTS )? &lt;identifier&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">KEYSPACE</span> myApp;
</span></span></code></pre></div><p><code>DROP KEYSPACE</code> 将会立刻完成，不可逆地删除掉一个键空间，包括键空间下的所有的键族和这些键族中的数据。</p>
<p>如果键空间不存在，且没有加上 <code>IF EXISTS</code>，执行将会报错；加上则为无操作。</p>
<h3 id="create-table-创建表">CREATE TABLE 创建表</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-table-stmt&gt; ::= CREATE ( TABLE | COLUMNFAMILY ) ( IF NOT EXISTS )? &lt;tablename&gt;
                          &#39;(&#39; &lt;column-definition&gt; ( &#39;,&#39; &lt;column-definition&gt; )* &#39;)&#39;
                          ( WITH &lt;option&gt; ( AND &lt;option&gt;)* )?

&lt;column-definition&gt; ::= &lt;identifier&gt; &lt;type&gt; ( STATIC )? ( PRIMARY KEY )?
                      | PRIMARY KEY &#39;(&#39; &lt;partition-key&gt; ( &#39;,&#39; &lt;identifier&gt; )* &#39;)&#39;

&lt;partition-key&gt; ::= &lt;identifier&gt;
                  | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt; )* &#39;)&#39;

&lt;option&gt; ::= &lt;property&gt;
           | COMPACT STORAGE
           | CLUSTERING ORDER
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> monkeySpecies (
</span></span><span style="display:flex;"><span>    species <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    common_name <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    population <span style="color:#8be9fd;font-style:italic">varint</span>,
</span></span><span style="display:flex;"><span>    average_size <span style="color:#8be9fd;font-style:italic">int</span>
</span></span><span style="display:flex;"><span>) <span style="color:#ff79c6">WITH</span> comment<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Important biological records&#39;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">AND</span> read_repair_chance <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> timeline (
</span></span><span style="display:flex;"><span>    userid <span style="color:#8be9fd;font-style:italic">uuid</span>,
</span></span><span style="display:flex;"><span>    posted_month <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    posted_time <span style="color:#8be9fd;font-style:italic">uuid</span>,
</span></span><span style="display:flex;"><span>    body <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    posted_by <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span> (userid, posted_month, posted_time)
</span></span><span style="display:flex;"><span>) <span style="color:#ff79c6">WITH</span> compaction <span style="color:#ff79c6">=</span> { <span style="color:#f1fa8c">&#39;class&#39;</span> : <span style="color:#f1fa8c">&#39;LeveledCompactionStrategy&#39;</span> };
</span></span></code></pre></div><p>出于历史原因，<code>CREATE COLUMNFAMILY</code> 为 <code>CREATE TABLE</code> 的别名。</p>
<h4 id="tablename"><code>&lt;tablename&gt;</code></h4>
<p>与键空间命名相同规则，最大32位的字母数字标识符。如果建表时未提供键空间，则在当前的键空间下创建；否则在指定的键空间下创建，但不会切换当前键空间。</p>
<h4 id="column-definition"><code>&lt;column-definition&gt;</code></h4>
<p>在 CQL 中，如果 <code>PRIMARY KEY</code> 由多栏组成，那么其顺序非常重要。 <code>PRIMARY KEY</code> 中的第一栏被称为分区键（<em>partition key</em>），共享相同分区键的所有行（实际上甚至跨表）都存储在同一个物理节点上。并且，对共享同一个分区键的行的插入、更新、删除操作，是原子且隔离的。分区键同样允许由多栏共同构成，使用括号括住即可。</p>
<p><code>PRIMARY KEY</code>中的其他栏则被称为聚集键（<em>clustering columns</em>）。在一个给定的物理节点上，一个给定分区键的行是按照聚集键的顺序存储的，这使得按照该集群顺序检索行特别高效(参见SELECT)。</p>
<h4 id="static-columns"><code>STATIC</code> columns</h4>
<p><code>STATIC</code> 静态栏会使同一个分区键的每一行共享同一个数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> test (
</span></span><span style="display:flex;"><span>    pk <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    t <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    v <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    s <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">static</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span> (pk, t)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> test(pk, t, v, s) <span style="color:#ff79c6">VALUES</span> (<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#f1fa8c">&#39;val0&#39;</span>, <span style="color:#f1fa8c">&#39;static0&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> test(pk, t, v, s) <span style="color:#ff79c6">VALUES</span> (<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#f1fa8c">&#39;val1&#39;</span>, <span style="color:#f1fa8c">&#39;static1&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> test <span style="color:#ff79c6">WHERE</span> pk<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span> <span style="color:#ff79c6">AND</span> t<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 结果：s=&#39;static1&#39;
</span></span></span></code></pre></div><p>对于不同的分区键，则不会共享同样的数据。</p>
<p>如果使用静态栏，则会存在以下这些限制：</p>
<ul>
<li>使用 <code>COMPACT STORAGE</code> 选项的表不支持</li>
<li>对于没有聚集键的表，不能拥有静态栏（因为此时不会存在共享分区键的不同行）</li>
<li>只有非 <code>PRIMARY KEY</code> 栏才能是静态的</li>
</ul>
<h4 id="option"><code>&lt;option&gt;</code></h4>
<p><code>COMPACT STORAGE</code>：主要是向后兼容对CQL3以前的定义。这项属性会使存储更加紧凑，但也失去了拓展性和灵活性。最显著的一点是，紧凑存储的表不能拥有静态栏，而且一定需要有且只能有1个聚集键。因此除非兼容考虑一般不推荐使用。</p>
<p><code>CLUSTERING ORDER</code>：允许定义行在硬盘中的排序。注意这项设置会影响 <code>SELECT</code> 的 <code>ORDER BY</code> 选项。</p>
<p>以下表格显示了其他支持的 <code>&lt;property&gt;</code>：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>kind</th>
<th>default</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>comment</code></td>
<td><em>simple</em></td>
<td>none</td>
<td>注释。</td>
</tr>
<tr>
<td><code>read_repair_chance</code></td>
<td><em>simple</em></td>
<td>0.1</td>
<td>为读取修复而查询额外节点（例如超过一致性级别所需的节点）的概率。</td>
</tr>
<tr>
<td><code>dclocal_read_repair_chance</code></td>
<td><em>simple</em></td>
<td>0</td>
<td>为读取修复而查询属于同一数据中心的额外节点（例如多于一致性级别所需的节点）的概率。</td>
</tr>
<tr>
<td><code>gc_grace_seconds</code></td>
<td><em>simple</em></td>
<td>864000</td>
<td>垃圾收集墓碑（删除标记）之前等待的时间。</td>
</tr>
<tr>
<td><code>bloom_filter_fp_chance</code></td>
<td><em>simple</em></td>
<td>0.00075</td>
<td>SSTable布隆过滤器的目标误判率。将参考此值调整布隆过滤器的大小。</td>
</tr>
<tr>
<td><code>default_time_to_live</code></td>
<td><em>simple</em></td>
<td>0</td>
<td>一张表的默认TTL秒数。</td>
</tr>
<tr>
<td><code>compaction</code></td>
<td><em>map</em></td>
<td><em>see below</em></td>
<td>压实选项，见下文。</td>
</tr>
<tr>
<td><code>compression</code></td>
<td><em>map</em></td>
<td><em>see below</em></td>
<td>压缩选项，见下文。</td>
</tr>
<tr>
<td><code>caching</code></td>
<td><em>map</em></td>
<td><em>see below</em></td>
<td>缓存选项，见下文。</td>
</tr>
</tbody>
</table>
<h4 id="compaction-options">Compaction options</h4>
<p>至少需要定义 <code>class</code> 子选项，定义了要使用的压实策略。默认支持<code>'SizeTieredCompactionStrategy'</code>, <code>'LeveledCompactionStrategy'</code> 和 <code>'DateTieredCompactionStrategy'</code>。可以通过将完整类名指定为字符串常量来提供自定义策略。其余的子选项取决于所选的类。默认类支持的子选项包括：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>supported compaction strategy</th>
<th>default</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>enabled</code></td>
<td><em>all</em></td>
<td>true</td>
<td>A boolean denoting whether compaction should be enabled or not.</td>
</tr>
<tr>
<td><code>tombstone_threshold</code></td>
<td><em>all</em></td>
<td>0.2</td>
<td>A ratio such that if a sstable has more than this ratio of gcable tombstones over all contained columns, the sstable will be compacted (with no other sstables) for the purpose of purging those tombstones.</td>
</tr>
<tr>
<td><code>tombstone_compaction_interval</code></td>
<td><em>all</em></td>
<td>1 day</td>
<td>The minimum time to wait after an sstable creation time before considering it for “tombstone compaction”, where “tombstone compaction” is the compaction triggered if the sstable has more gcable tombstones than <code>tombstone_threshold</code>.</td>
</tr>
<tr>
<td><code>unchecked_tombstone_compaction</code></td>
<td><em>all</em></td>
<td>false</td>
<td>Setting this to true enables more aggressive tombstone compactions – single sstable tombstone compactions will run without checking how likely it is that they will be successful.</td>
</tr>
<tr>
<td><code>min_sstable_size</code></td>
<td>SizeTieredCompactionStrategy</td>
<td>50MB</td>
<td>The size tiered strategy groups SSTables to compact in buckets. A bucket groups SSTables that differs from less than 50% in size. However, for small sizes, this would result in a bucketing that is too fine grained. <code>min_sstable_size</code> defines a size threshold (in bytes) below which all SSTables belong to one unique bucket</td>
</tr>
<tr>
<td><code>min_threshold</code></td>
<td>SizeTieredCompactionStrategy</td>
<td>4</td>
<td>Minimum number of SSTables needed to start a minor compaction.</td>
</tr>
<tr>
<td><code>max_threshold</code></td>
<td>SizeTieredCompactionStrategy</td>
<td>32</td>
<td>Maximum number of SSTables processed by one minor compaction.</td>
</tr>
<tr>
<td><code>bucket_low</code></td>
<td>SizeTieredCompactionStrategy</td>
<td>0.5</td>
<td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%)</td>
</tr>
<tr>
<td><code>bucket_high</code></td>
<td>SizeTieredCompactionStrategy</td>
<td>1.5</td>
<td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%).</td>
</tr>
<tr>
<td><code>sstable_size_in_mb</code></td>
<td>LeveledCompactionStrategy</td>
<td>5MB</td>
<td>The target size (in MB) for sstables in the leveled strategy. Note that while sstable sizes should stay less or equal to <code>sstable_size_in_mb</code>, it is possible to exceptionally have a larger sstable as during compaction, data for a given partition key are never split into 2 sstables</td>
</tr>
<tr>
<td><code>timestamp_resolution</code></td>
<td>DateTieredCompactionStrategy</td>
<td>MICROSECONDS</td>
<td>The timestamp resolution used when inserting data, could be MILLISECONDS, MICROSECONDS etc (should be understandable by Java TimeUnit) - don’t change this unless you do mutations with USING TIMESTAMP (or equivalent directly in the client)</td>
</tr>
<tr>
<td><code>base_time_seconds</code></td>
<td>DateTieredCompactionStrategy</td>
<td>60</td>
<td>The base size of the time windows.</td>
</tr>
<tr>
<td><code>max_sstable_age_days</code></td>
<td>DateTieredCompactionStrategy</td>
<td>365</td>
<td>SSTables only containing data that is older than this will never be compacted.</td>
</tr>
</tbody>
</table>
<h4 id="compression-options">Compression options</h4>
<p>有以下这些子选项：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>default</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>class</code></td>
<td>LZ4Compressor</td>
<td>The compression algorithm to use. Default compressor are: LZ4Compressor, SnappyCompressor and DeflateCompressor. Use <code>'enabled' : false</code> to disable compression. Custom compressor can be provided by specifying the full class name as a <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#constants">string constant</a>.</td>
</tr>
<tr>
<td><code>enabled</code></td>
<td>true</td>
<td>By default compression is enabled. To disable it, set <code>enabled</code> to <code>false</code></td>
</tr>
<tr>
<td><code>chunk_length_in_kb</code></td>
<td>64KB</td>
<td>On disk SSTables are compressed by block (to allow random reads). This defines the size (in KB) of said block. Bigger values may improve the compression rate, but increases the minimum size of data to be read from disk for a read</td>
</tr>
<tr>
<td><code>crc_check_chance</code></td>
<td>1.0</td>
<td>When compression is enabled, each compressed block includes a checksum of that block for the purpose of detecting disk bitrot and avoiding the propagation of corruption to other replica. This option defines the probability with which those checksums are checked during read. By default they are always checked. Set to 0 to disable checksum checking and to 0.5 for instance to check them every other read</td>
</tr>
</tbody>
</table>
<h4 id="caching-options">Caching options</h4>
<table>
<thead>
<tr>
<th>option</th>
<th>default</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>keys</code></td>
<td>ALL</td>
<td>Whether to cache keys (“key cache”) for this table. Valid values are: <code>ALL</code> and <code>NONE</code>.</td>
</tr>
<tr>
<td><code>rows_per_partition</code></td>
<td>NONE</td>
<td>The amount of rows to cache per partition (“row cache”). If an integer <code>n</code> is specified, the first <code>n</code> queried rows of a partition will be cached. Other possible options are <code>ALL</code>, to cache all rows of a queried partition, or <code>NONE</code> to disable row caching.</td>
</tr>
</tbody>
</table>
<h4 id="其他注意事项">其他注意事项</h4>
<ul>
<li>在插入/更新一行数据时，并非所有栏都需要被定义，并且没有的栏不会占据硬盘的空间。此外，添加一列新栏是一个常数级的操作，因此在建表时不需要去预料猜测未来的用法。</li>
</ul>
<h3 id="alter-table-修改表">ALTER TABLE 修改表</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;alter-table-stmt&gt; ::= ALTER (TABLE | COLUMNFAMILY) &lt;tablename&gt; &lt;instruction&gt;

&lt;instruction&gt; ::= ALTER &lt;identifier&gt; TYPE &lt;type&gt;
                | ADD   &lt;identifier&gt; &lt;type&gt;
                | DROP  &lt;identifier&gt;
                | WITH  &lt;option&gt; ( AND &lt;option&gt; )*
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TABLE</span> addamsFamily
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> lastKnownLocation <span style="color:#ff79c6">TYPE</span> <span style="color:#8be9fd;font-style:italic">uuid</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TABLE</span> addamsFamily
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ADD</span> gravesite <span style="color:#8be9fd;font-style:italic">varchar</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TABLE</span> addamsFamily
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">WITH</span> comment <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;A most excellent and useful column family&#39;</span>
</span></span><span style="display:flex;"><span> <span style="color:#ff79c6">AND</span> read_repair_chance <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0.2</span>;
</span></span></code></pre></div><p><code>&lt;instruction&gt;</code> 的不同语句的功能：</p>
<ul>
<li>
<p><code>ALTER</code>：更新某一栏的类型。注意，不能修改聚集键的类型和位于二级索引下的列。更新类型时不会进行类型校验，但最好不要将一种类型转换为其不兼容的类型，除非此栏中没有数据，不然会导致 CQL 驱动、工具混乱。</p>
</li>
<li>
<p><code>ADD</code>：添加一列新栏。不能与已存在的冲突；使用 <code>COMPACT STORAGE</code> 选项的表无法添加。</p>
</li>
<li>
<p><code>DROP</code>：移除某一栏。删除的列将立即在查询中不可用，将来也不会包含在压缩的sstable中。如果一列被读取，查询将不会返回在最后删除该列之前写入的值。使用 <code>COMPACT STORAGE</code> 选项的表无法删除列。</p>
</li>
<li>
<p><code>WITH</code>：更新表的选项。支持的选项与建表语句相同，但是 <code>COMPACT STORAGE</code> 除外。需要注意的是，设置任何压实子选项都会删除以前所有的压实选项，因此如果想保留它们，就需要重新指定所有的子选项。压缩子选项集也一样。</p>
</li>
</ul>
<h3 id="drop-table-删除表">DROP TABLE 删除表</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-table-stmt&gt; ::= DROP TABLE ( IF EXISTS )? &lt;tablename&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">TABLE</span> worldSeriesAttendees;
</span></span></code></pre></div><h3 id="truncate-清空表">TRUNCATE 清空表</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;truncate-stmt&gt; ::= TRUNCATE ( TABLE | COLUMNFAMILY )? &lt;tablename&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">TRUNCATE</span> superImportantData;
</span></span></code></pre></div><h3 id="create-index-创建二级索引">CREATE INDEX 创建二级索引</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-index-stmt&gt; ::= CREATE ( CUSTOM )? INDEX ( IF NOT EXISTS )? ( &lt;indexname&gt; )?
                            ON &lt;tablename&gt; &#39;(&#39; &lt;index-identifier&gt; &#39;)&#39;
                            ( USING &lt;string&gt; ( WITH OPTIONS = &lt;map-literal&gt; )? )?

&lt;index-identifier&gt; ::= &lt;identifier&gt;
                     | keys( &lt;identifier&gt; )
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> userIndex <span style="color:#ff79c6">ON</span> NerdMovies (<span style="color:#ff79c6">user</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> <span style="color:#ff79c6">ON</span> Mutants (abilityId);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">users</span> (<span style="color:#ff79c6">keys</span>(favs));
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">CUSTOM</span> <span style="color:#ff79c6">INDEX</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">users</span> (email) <span style="color:#ff79c6">USING</span> <span style="color:#f1fa8c">&#39;path.to.the.IndexClass&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">CUSTOM</span> <span style="color:#ff79c6">INDEX</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">users</span> (email) <span style="color:#ff79c6">USING</span> <span style="color:#f1fa8c">&#39;path.to.the.IndexClass&#39;</span> <span style="color:#ff79c6">WITH</span> <span style="color:#ff79c6">OPTIONS</span> <span style="color:#ff79c6">=</span> {<span style="color:#f1fa8c">&#39;storage&#39;</span>: <span style="color:#f1fa8c">&#39;/mnt/ssd/indexes/&#39;</span>};
</span></span></code></pre></div><p>如果需要，可以在ON关键字之前指定索引本身的名称。如果该列的数据已经存在，则将对其进行异步索引。创建索引之后，列的新数据将在插入时自动建立索引。</p>
<p>在map列上创建索引时，可以对键或值建立索引。如果列标识符位于 <code>keys() </code> 函数内，则索引将位于map键上，从而允许在 WHERE 子句中使用 <code>CONTAINS KEY</code>。否则，索引将位于map值上。</p>
<h3 id="drop-index-删除索引">DROP INDEX 删除索引</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-index-stmt&gt; ::= DROP INDEX ( IF EXISTS )? ( &lt;keyspace&gt; &#39;.&#39; )? &lt;identifier&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">INDEX</span> userIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">INDEX</span> userkeyspace.address_index;
</span></span></code></pre></div><h3 id="materialized-view-物化视图">MATERIALIZED VIEW 物化视图</h3>
<p>此处暂略相关内容。</p>
<h3 id="create-type-创建类型">CREATE TYPE 创建类型</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-type-stmt&gt; ::= CREATE TYPE ( IF NOT EXISTS )? &lt;typename&gt;
                         &#39;(&#39; &lt;field-definition&gt; ( &#39;,&#39; &lt;field-definition&gt; )* &#39;)&#39;

&lt;typename&gt; ::= ( &lt;keyspace-name&gt; &#39;.&#39; )? &lt;identifier&gt;

&lt;field-definition&gt; ::= &lt;identifier&gt; &lt;type&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TYPE</span> address (
</span></span><span style="display:flex;"><span>    street_name <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    street_number <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    city <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    state <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    zip <span style="color:#8be9fd;font-style:italic">int</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TYPE</span> work_and_home_addresses (
</span></span><span style="display:flex;"><span>    home_address address,
</span></span><span style="display:flex;"><span>    work_address address
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>创建自定义类型，每个类型都是一组明确命名、明确类型的字段集合。字段类型可以是任何有效的类型，包括集合和其他已存在的用户自定义类型。</p>
<h4 id="typename"><code>&lt;typename&gt;</code></h4>
<p>有效的类型名是标识符。不能使用现有的CQL类型名和保留类型名。</p>
<p>如果只提供类型名，则使用当前键空间创建类型（参考 <code>USE</code>）。如果以存在的键空间名称作为前缀，则该类型将在指定的键空间中创建，而不是在当前键空间中创建。</p>
<h3 id="alter-type-修改类型">ALTER TYPE 修改类型</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;alter-type-stmt&gt; ::= ALTER TYPE &lt;typename&gt; &lt;instruction&gt;

&lt;instruction&gt; ::= ALTER &lt;field-name&gt; TYPE &lt;type&gt;
                | ADD &lt;field-name&gt; &lt;type&gt;
                | RENAME &lt;field-name&gt; TO &lt;field-name&gt; ( AND &lt;field-name&gt; TO &lt;field-name&gt; )*
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TYPE</span> address <span style="color:#ff79c6">ALTER</span> zip <span style="color:#ff79c6">TYPE</span> <span style="color:#8be9fd;font-style:italic">varint</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TYPE</span> address <span style="color:#ff79c6">ADD</span> country <span style="color:#8be9fd;font-style:italic">text</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ALTER</span> <span style="color:#ff79c6">TYPE</span> address <span style="color:#ff79c6">RENAME</span> zip <span style="color:#ff79c6">TO</span> zipcode <span style="color:#ff79c6">AND</span> street_name <span style="color:#ff79c6">TO</span> street
</span></span></code></pre></div><p>允许添加新字段、重命名现有字段或更改现有字段的类型。更改列的类型时，新类型必须与旧类型兼容。</p>
<h3 id="drop-type-删除类型">DROP TYPE 删除类型</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-type-stmt&gt; ::= DROP TYPE ( IF EXISTS )? &lt;typename&gt;
</code></pre><p>立即、不可逆地删除一个类型。</p>
<h3 id="create-trigger-创建触发器">CREATE TRIGGER 创建触发器</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-trigger-stmt&gt; ::= CREATE TRIGGER ( IF NOT EXISTS )? ( &lt;triggername&gt; )?
                            ON &lt;tablename&gt; 
                            USING &lt;string&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TRIGGER</span> myTrigger <span style="color:#ff79c6">ON</span> myTable <span style="color:#ff79c6">USING</span> <span style="color:#f1fa8c">&#39;org.apache.cassandra.triggers.InvertedIndex&#39;</span>;
</span></span></code></pre></div><p>触发器的实际逻辑可以用任何 JVM 语言编写，并且存放在数据库之外。将触发器代码放在Cassandra安装目录的lib/triggers 子目录中，在集群启动期间将会加载，并存在于集群的各个节点上。在表上定义的触发器会在请求的DML 语句触发之前触发，从而确保了事务的原子性。</p>
<h3 id="drop-trigger-删除触发器">DROP TRIGGER 删除触发器</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-trigger-stmt&gt; ::= DROP TRIGGER ( IF EXISTS )? ( &lt;triggername&gt; )?
                            ON &lt;tablename&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">TRIGGER</span> myTrigger <span style="color:#ff79c6">ON</span> myTable;
</span></span></code></pre></div><h3 id="create-function-创建函数">CREATE FUNCTION 创建函数</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-function-stmt&gt; ::= CREATE ( OR REPLACE )? 
                            FUNCTION ( IF NOT EXISTS )?
                            ( &lt;keyspace&gt; &#39;.&#39; )? &lt;function-name&gt;
                            &#39;(&#39; &lt;arg-name&gt; &lt;arg-type&gt; ( &#39;,&#39; &lt;arg-name&gt; &lt;arg-type&gt; )* &#39;)&#39;
                            ( CALLED | RETURNS NULL ) ON NULL INPUT
                            RETURNS &lt;type&gt;
                            LANGUAGE &lt;language&gt;
                            AS &lt;body&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">OR</span> <span style="color:#ff79c6">REPLACE</span> <span style="color:#ff79c6">FUNCTION</span> somefunction
</span></span><span style="display:flex;"><span>    ( somearg <span style="color:#8be9fd;font-style:italic">int</span>, anotherarg <span style="color:#8be9fd;font-style:italic">text</span>, complexarg <span style="color:#8be9fd;font-style:italic">frozen</span><span style="color:#ff79c6">&lt;</span>someUDT<span style="color:#ff79c6">&gt;</span>, listarg <span style="color:#8be9fd;font-style:italic">list</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">bigint</span><span style="color:#ff79c6">&gt;</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">RETURNS</span> <span style="color:#ff79c6">NULL</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">NULL</span> <span style="color:#ff79c6">INPUT</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">RETURNS</span> <span style="color:#8be9fd;font-style:italic">text</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">LANGUAGE</span> <span style="color:#8be9fd;font-style:italic">java</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">AS</span> <span style="color:#f1fa8c">$$</span>
</span></span><span style="display:flex;"><span>       <span style="color:#6272a4">// some Java code
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#f1fa8c">$$</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">FUNCTION</span> akeyspace.fname <span style="color:#ff79c6">IF</span> <span style="color:#ff79c6">NOT</span> <span style="color:#ff79c6">EXISTS</span>
</span></span><span style="display:flex;"><span>    ( someArg <span style="color:#8be9fd;font-style:italic">int</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">CALLED</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">NULL</span> <span style="color:#ff79c6">INPUT</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">RETURNS</span> <span style="color:#8be9fd;font-style:italic">text</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">LANGUAGE</span> <span style="color:#8be9fd;font-style:italic">java</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">AS</span> <span style="color:#f1fa8c">$$</span>
</span></span><span style="display:flex;"><span>       <span style="color:#6272a4">// some Java code
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#f1fa8c">$$</span>;
</span></span></code></pre></div><p>暂略。</p>
<h3 id="drop-function-删除函数">DROP FUNCTION 删除函数</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-function-stmt&gt; ::= DROP FUNCTION ( IF EXISTS )?
                         ( &lt;keyspace&gt; &#39;.&#39; )? &lt;function-name&gt;
                         ( &#39;(&#39; &lt;arg-type&gt; ( &#39;,&#39; &lt;arg-type&gt; )* &#39;)&#39; )?
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">FUNCTION</span> myfunction;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">FUNCTION</span> mykeyspace.afunction;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">FUNCTION</span> afunction ( <span style="color:#8be9fd;font-style:italic">int</span> );
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">FUNCTION</span> afunction ( <span style="color:#8be9fd;font-style:italic">text</span> );
</span></span></code></pre></div><p>暂略。</p>
<h3 id="create-aggregate-创建聚合函数">CREATE AGGREGATE 创建聚合函数</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;create-aggregate-stmt&gt; ::= CREATE ( OR REPLACE )? 
                            AGGREGATE ( IF NOT EXISTS )?
                            ( &lt;keyspace&gt; &#39;.&#39; )? &lt;aggregate-name&gt;
                            &#39;(&#39; &lt;arg-type&gt; ( &#39;,&#39; &lt;arg-type&gt; )* &#39;)&#39;
                            SFUNC &lt;state-functionname&gt;
                            STYPE &lt;state-type&gt;
                            ( FINALFUNC &lt;final-functionname&gt; )?
                            ( INITCOND &lt;init-cond&gt; )?
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">AGGREGATE</span> myaggregate ( val <span style="color:#8be9fd;font-style:italic">text</span> )
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">SFUNC</span> myaggregate_state
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">STYPE</span> <span style="color:#8be9fd;font-style:italic">text</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">FINALFUNC</span> myaggregate_final
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">INITCOND</span> <span style="color:#f1fa8c">&#39;foo&#39;</span>;
</span></span></code></pre></div><p>可以创建或替换用户自定义聚合函数。</p>
<p>暂略。</p>
<h3 id="drop-aggregate-删除聚合函数">DROP AGGREGATE 删除聚合函数</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;drop-aggregate-stmt&gt; ::= DROP AGGREGATE ( IF EXISTS )?
                         ( &lt;keyspace&gt; &#39;.&#39; )? &lt;aggregate-name&gt;
                         ( &#39;(&#39; &lt;arg-type&gt; ( &#39;,&#39; &lt;arg-type&gt; )* &#39;)&#39; )?
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">AGGREGATE</span> myAggregate;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">AGGREGATE</span> myKeyspace.anAggregate;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">AGGREGATE</span> someAggregate ( <span style="color:#8be9fd;font-style:italic">int</span> );
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DROP</span> <span style="color:#ff79c6">AGGREGATE</span> someAggregate ( <span style="color:#8be9fd;font-style:italic">text</span> );
</span></span></code></pre></div><p>暂略。</p>
<h2 id="数据操作">数据操作</h2>
<h3 id="insert-插入数据">INSERT 插入数据</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;insertStatement&gt; ::= INSERT INTO &lt;tablename&gt;
                      ( ( &lt;name-list&gt; VALUES &lt;value-list&gt; )
                      | ( JSON &lt;string&gt; ))
                      ( IF NOT EXISTS )?
                      ( USING &lt;option&gt; ( AND &lt;option&gt; )* )?

&lt;names-list&gt; ::= &#39;(&#39; &lt;identifier&gt; ( &#39;,&#39; &lt;identifier&gt; )* &#39;)&#39;

&lt;value-list&gt; ::= &#39;(&#39; &lt;term-or-literal&gt; ( &#39;,&#39; &lt;term-or-literal&gt; )* &#39;)&#39;

&lt;term-or-literal&gt; ::= &lt;term&gt;
                    | &lt;collection-literal&gt;

&lt;option&gt; ::= TIMESTAMP &lt;integer&gt;
           | TTL &lt;integer&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> NerdMovies (movie, director, main_actor, year)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;Serenity&#39;</span>, <span style="color:#f1fa8c">&#39;Joss Whedon&#39;</span>, <span style="color:#f1fa8c">&#39;Nathan Fillion&#39;</span>, <span style="color:#bd93f9">2005</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">USING</span> <span style="color:#ff79c6">TTL</span> <span style="color:#bd93f9">86400</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> NerdMovies <span style="color:#ff79c6">JSON</span> <span style="color:#f1fa8c">&#39;{&#34;movie&#34;: &#34;Serenity&#34;, &#34;director&#34;: &#34;Joss Whedon&#34;, &#34;year&#34;: 2005}&#39;</span>
</span></span></code></pre></div><ul>
<li>插入数据必须指定所有的主键</li>
<li>当使用 <code>VALUES</code> 语法时，必须提供要插入的数据列表；当使用 <code>JSON</code> 语法时，这是可选的。</li>
<li>与 SQL 不同，<code>INSERT</code> 默认不会检查此行是否已经存在。如果主键不存在，插入将会新增；否则则更新。此外，也无法知道实际上是进行了创建还是更新。</li>
<li>但是，可以使用 <code>IF NOT EXISTS</code> 条件，仅在不存在相应行的情况下进行插入。但请注意，如果使用<code>IF NOT EXISTS</code>，将会导致不可忽视的性能损失（内部会使用 Paxos），所以应该谨慎使用。</li>
<li><code>INSERT </code>的所有更新都是原子且独立地应用的。</li>
<li><code>INSERT</code> 不支持计数器，而 <code>UPDATE</code> 支持。</li>
<li>可用的 <code>&lt;option&gt;</code> 选项请参考 <code>UPDATE</code> ，<code>&lt;collection-literal&gt;</code> 参考 <code>collections </code>。</li>
</ul>
<h3 id="update-更新数据">UPDATE 更新数据</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;update-stmt&gt; ::= UPDATE &lt;tablename&gt;
                  ( USING &lt;option&gt; ( AND &lt;option&gt; )* )?
                  SET &lt;assignment&gt; ( &#39;,&#39; &lt;assignment&gt; )*
                  WHERE &lt;where-clause&gt;
                  ( IF &lt;condition&gt; ( AND condition )* )?

&lt;assignment&gt; ::= &lt;identifier&gt; &#39;=&#39; &lt;term&gt;
               | &lt;identifier&gt; &#39;=&#39; &lt;identifier&gt; (&#39;+&#39; | &#39;-&#39;) (&lt;int-term&gt; | &lt;set-literal&gt; | &lt;list-literal&gt;)
               | &lt;identifier&gt; &#39;=&#39; &lt;identifier&gt; &#39;+&#39; &lt;map-literal&gt;
               | &lt;identifier&gt; &#39;[&#39; &lt;term&gt; &#39;]&#39; &#39;=&#39; &lt;term&gt;

&lt;condition&gt; ::= &lt;identifier&gt; &lt;op&gt; &lt;term&gt;
              | &lt;identifier&gt; IN (&lt;variable&gt; | &#39;(&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt; )* )? &#39;)&#39;)
              | &lt;identifier&gt; &#39;[&#39; &lt;term&gt; &#39;]&#39; &lt;op&gt; &lt;term&gt;
              | &lt;identifier&gt; &#39;[&#39; &lt;term&gt; &#39;]&#39; IN &lt;term&gt;

&lt;op&gt; ::= &#39;&lt;&#39; | &#39;&lt;=&#39; | &#39;=&#39; | &#39;!=&#39; | &#39;&gt;=&#39; | &#39;&gt;&#39;

&lt;where-clause&gt; ::= &lt;relation&gt; ( AND &lt;relation&gt; )*

&lt;relation&gt; ::= &lt;identifier&gt; &#39;=&#39; &lt;term&gt;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; &#39;=&#39; &lt;term-tuple&gt;
             | &lt;identifier&gt; IN &#39;(&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt;)* )? &#39;)&#39;
             | &lt;identifier&gt; IN &lt;variable&gt;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; IN &#39;(&#39; ( &lt;term-tuple&gt; ( &#39;,&#39; &lt;term-tuple&gt;)* )? &#39;)&#39;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; IN &lt;variable&gt;

&lt;option&gt; ::= TIMESTAMP &lt;integer&gt;
           | TTL &lt;integer&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> NerdMovies <span style="color:#ff79c6">USING</span> <span style="color:#ff79c6">TTL</span> <span style="color:#bd93f9">400</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">SET</span> director <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;Joss Whedon&#39;</span>,
</span></span><span style="display:flex;"><span>    main_actor <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;Nathan Fillion&#39;</span>,
</span></span><span style="display:flex;"><span>    year <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2005</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">WHERE</span> movie <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;Serenity&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> UserActions <span style="color:#8be9fd;font-style:italic">SET</span> total <span style="color:#ff79c6">=</span> total <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">WHERE</span> <span style="color:#ff79c6">user</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">B70DE1D0-9908-4AE3-BE34-5573E5B09F14</span> <span style="color:#ff79c6">AND</span> action <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;click&#39;</span>;
</span></span></code></pre></div><ul>
<li>可以更新指定一行的一或多列数据。</li>
<li><code>&lt;where-clause&gt;</code> 必须包含所有的主键。</li>
<li>与 SQL 不同，<code>UPDATE</code> 默认不会检查此行是否已经存在。如果主键不存在，将会新增行；否则则更新。此外，也无法知道实际上是进行了创建还是更新。</li>
<li>但是可以使用 <code>IF</code> 在列上使用条件来决定是否要更新。但这会导致不可忽视的性能损失（内部会使用 Paxos），所以应该谨慎使用。</li>
<li>同一个分区键内的所有更新都是原子且独立地应用的。</li>
<li><code>&lt;assignment&gt;</code> 的 <code>c=c+3</code> 形式用于递增/递减计数器。“=” 前后的标识符必须相同（计数器只支持递增/递减，不支持赋值特定值）。</li>
<li><code>&lt;assignment&gt;</code>  中的 <code>id = id + &lt;collection-literal&gt;</code> 和 <code>id[value1] = value2</code> 用于集合，具体请参考相关章节。</li>
</ul>
<h4 id="options"><code>&lt;options&gt;</code></h4>
<p><code>UPDATE</code> 和 <code>INSERT</code>  支持以下设置：</p>
<ul>
<li><code>TIMESTAMP</code>：设置操作的时间戳。如果没有指定，协调器将使用语句执行开始时的时间（微秒）作为时间戳。这一般是合适的默认值。</li>
<li><code>TTL</code>：对插入的数据指定生存时间（秒）。如果设置了该值，在指定的时间之后，插入的值将自动从数据库中删除。需要注意的是 TTL 作用的是值而不是列本身，因此此列的任何后续更新都会刷新 TTL 为更新时指定的 TTL 值。TTL 为 0 或负数则代表无 TTL（默认情况），值不会过期。</li>
</ul>
<h3 id="delete-删除数据">DELETE 删除数据</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;delete-stmt&gt; ::= DELETE ( &lt;selection&gt; ( &#39;,&#39; &lt;selection&gt; )* )?
                  FROM &lt;tablename&gt;
                  ( USING TIMESTAMP &lt;integer&gt;)?
                  WHERE &lt;where-clause&gt;
                  ( IF ( EXISTS | ( &lt;condition&gt; ( AND &lt;condition&gt; )*) ) )?

&lt;selection&gt; ::= &lt;identifier&gt; ( &#39;[&#39; &lt;term&gt; &#39;]&#39; )?

&lt;where-clause&gt; ::= &lt;relation&gt; ( AND &lt;relation&gt; )*

&lt;relation&gt; ::= &lt;identifier&gt; &lt;op&gt; &lt;term&gt;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; &lt;op&gt; &lt;term-tuple&gt;
             | &lt;identifier&gt; IN &#39;(&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt;)* )? &#39;)&#39;
             | &lt;identifier&gt; IN &lt;variable&gt;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; IN &#39;(&#39; ( &lt;term-tuple&gt; ( &#39;,&#39; &lt;term-tuple&gt;)* )? &#39;)&#39;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; IN &lt;variable&gt;

&lt;op&gt; ::= &#39;=&#39; | &#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39;

&lt;condition&gt; ::= &lt;identifier&gt; (&lt;op&gt; | &#39;!=&#39;) &lt;term&gt;
              | &lt;identifier&gt; IN (&lt;variable&gt; | &#39;(&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt; )* )? &#39;)&#39;)
              | &lt;identifier&gt; &#39;[&#39; &lt;term&gt; &#39;]&#39; (&lt;op&gt; | &#39;!=&#39;) &lt;term&gt;
              | &lt;identifier&gt; &#39;[&#39; &lt;term&gt; &#39;]&#39; IN &lt;term&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DELETE</span> <span style="color:#ff79c6">FROM</span> NerdMovies <span style="color:#ff79c6">USING</span> <span style="color:#8be9fd;font-style:italic">TIMESTAMP</span> <span style="color:#bd93f9">1240003134</span> <span style="color:#ff79c6">WHERE</span> movie <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;Serenity&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">DELETE</span> phone <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">Users</span> <span style="color:#ff79c6">WHERE</span> userid <span style="color:#ff79c6">IN</span> (<span style="color:#bd93f9">C73DE1D3-AF08-40F3-B124-3FF3E5109F22</span>, <span style="color:#bd93f9">B70DE1D0-9908-4AE3-BE34-5573E5B09F14</span>);
</span></span></code></pre></div><ul>
<li>使用 <code>IN</code> 语法和范围操作符（如 &gt;=）可以批量删除</li>
<li>支持<code>TIMESTAMP</code>选项，其语义与<code>UPDATE</code>语句相同。</li>
<li>同一个分区键内的所有删除都是原子且独立地应用的。</li>
<li>使用 <code>IF</code> 语法会导致不可忽视的性能损失，类似 <code>INSERT</code> 和 <code>UPDATE</code>。</li>
</ul>
<h3 id="batch-批处理数据">BATCH 批处理数据</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;batch-stmt&gt; ::= BEGIN ( UNLOGGED | COUNTER ) BATCH
                 ( USING &lt;option&gt; ( AND &lt;option&gt; )* )?
                    &lt;modification-stmt&gt; ( &#39;;&#39; &lt;modification-stmt&gt; )*
                 APPLY BATCH

&lt;modification-stmt&gt; ::= &lt;insert-stmt&gt;
                      | &lt;update-stmt&gt;
                      | &lt;delete-stmt&gt;

&lt;option&gt; ::= TIMESTAMP &lt;integer&gt;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">BEGIN</span> <span style="color:#ff79c6">BATCH</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> <span style="color:#ff79c6">users</span> (userid, <span style="color:#ff79c6">password</span>, name) <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;user2&#39;</span>, <span style="color:#f1fa8c">&#39;ch@ngem3b&#39;</span>, <span style="color:#f1fa8c">&#39;second user&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">UPDATE</span> <span style="color:#ff79c6">users</span> <span style="color:#8be9fd;font-style:italic">SET</span> <span style="color:#ff79c6">password</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;ps22dhds&#39;</span> <span style="color:#ff79c6">WHERE</span> userid <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;user3&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> <span style="color:#ff79c6">users</span> (userid, <span style="color:#ff79c6">password</span>) <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;user4&#39;</span>, <span style="color:#f1fa8c">&#39;ch@ngem3c&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">DELETE</span> name <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> userid <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;user1&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">APPLY</span> <span style="color:#ff79c6">BATCH</span>;
</span></span></code></pre></div><p><code>BATCH</code> 可以将多条语句封装成一条语句执行，主要是以下作用：</p>
<ul>
<li>节省网络成本</li>
<li>一条 <code>BATCH</code> 中的所有对同一个分区键的更新是独立执行的</li>
<li>默认情况下，batch 里的所有操作都是以 <code>LOGGED</code> 执行的，以确保所有更改最终都被完成（或没有完成）。具体参考 <code> UNLOGGED</code>。</li>
</ul>
<p>注意：</p>
<ul>
<li><code>BATCH</code> 只能包含 <code>UPDATE</code>, <code>INSERT</code> 和 <code>DELETE</code> 语句。</li>
<li>批处理并<strong>不是</strong> SQL 事务的完全类似物。</li>
<li>如果没有为每个操作指定时间戳，那么所有操作都将应用相同的时间戳。时间戳与 Cassandra 的冲突解决策略相关，详情请参考时间戳相关章节。</li>
</ul>
<h4 id="unlogged"><code>UNLOGGED</code></h4>
<p>当批处理跨越多个分区时，其原子性会带来性能损失。如果想规避这种损失，可以使用 <code>UNLOGGED</code> 选项跳过 batchlog。代价是如果批处理失败了，可能会使补丁只作用了一部分。</p>
<h4 id="counter"><code>COUNTER</code></h4>
<p>批处理计数器更新。与 Cassandra 中的其他更新不同，计数器更新不是幂等的。</p>
<h4 id="option-1"><code>&lt;option&gt;</code></h4>
<p><code>BATCH</code> 也支持 <code>TIMESTAMP</code> 选项，和 <code>UPDATE</code> 的类似。如果 <code>BATCH</code> 使用了 <code>TIMESTAMP</code> ，那么内部的语句就不能再使用 <code>TIMESTAMP</code> 。</p>
<h2 id="查询">查询</h2>
<h3 id="select">SELECT</h3>
<p><em>Syntax:</em></p>
<pre tabindex="0"><code>&lt;select-stmt&gt; ::= SELECT ( JSON )? &lt;select-clause&gt;
                  FROM &lt;tablename&gt;
                  ( WHERE &lt;where-clause&gt; )?
                  ( ORDER BY &lt;order-by&gt; )?
                  ( LIMIT &lt;integer&gt; )?
                  ( ALLOW FILTERING )?

&lt;select-clause&gt; ::= DISTINCT? &lt;selection-list&gt;
                  | COUNT &#39;(&#39; ( &#39;*&#39; | &#39;1&#39; ) &#39;)&#39; (AS &lt;identifier&gt;)?

&lt;selection-list&gt; ::= &lt;selector&gt; (AS &lt;identifier&gt;)? ( &#39;,&#39; &lt;selector&gt; (AS &lt;identifier&gt;)? )*
                   | &#39;*&#39;

&lt;selector&gt; ::= &lt;identifier&gt;
             | WRITETIME &#39;(&#39; &lt;identifier&gt; &#39;)&#39;
             | TTL &#39;(&#39; &lt;identifier&gt; &#39;)&#39;
             | &lt;function&gt; &#39;(&#39; (&lt;selector&gt; (&#39;,&#39; &lt;selector&gt;)*)? &#39;)&#39;

&lt;where-clause&gt; ::= &lt;relation&gt; ( AND &lt;relation&gt; )*

&lt;relation&gt; ::= &lt;identifier&gt; &lt;op&gt; &lt;term&gt;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; &lt;op&gt; &lt;term-tuple&gt;
             | &lt;identifier&gt; IN &#39;(&#39; ( &lt;term&gt; ( &#39;,&#39; &lt;term&gt;)* )? &#39;)&#39;
             | &#39;(&#39; &lt;identifier&gt; (&#39;,&#39; &lt;identifier&gt;)* &#39;)&#39; IN &#39;(&#39; ( &lt;term-tuple&gt; ( &#39;,&#39; &lt;term-tuple&gt;)* )? &#39;)&#39;
             | TOKEN &#39;(&#39; &lt;identifier&gt; ( &#39;,&#39; &lt;identifer&gt;)* &#39;)&#39; &lt;op&gt; &lt;term&gt;

&lt;op&gt; ::= &#39;=&#39; | &#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39; | CONTAINS | CONTAINS KEY
&lt;order-by&gt; ::= &lt;ordering&gt; ( &#39;,&#39; &lt;odering&gt; )*
&lt;ordering&gt; ::= &lt;identifer&gt; ( ASC | DESC )?
&lt;term-tuple&gt; ::= &#39;(&#39; &lt;term&gt; (&#39;,&#39; &lt;term&gt;)* &#39;)&#39;
</code></pre><p><em>Sample:</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> name, occupation <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> userid <span style="color:#ff79c6">IN</span> (<span style="color:#bd93f9">199</span>, <span style="color:#bd93f9">200</span>, <span style="color:#bd93f9">207</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">JSON</span> name, occupation <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> userid <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">199</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> name <span style="color:#ff79c6">AS</span> user_name, occupation <span style="color:#ff79c6">AS</span> user_occupation <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#8be9fd;font-style:italic">time</span>, value
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span> events
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">WHERE</span> event_type <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;myEvent&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">AND</span> <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">&gt;</span> <span style="color:#f1fa8c">&#39;2011-02-03&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">AND</span> <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">&lt;=</span> <span style="color:#f1fa8c">&#39;2012-01-01&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">COUNT</span>(<span style="color:#ff79c6">*</span>) <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">COUNT</span>(<span style="color:#ff79c6">*</span>) <span style="color:#ff79c6">AS</span> user_count <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span>;
</span></span></code></pre></div><p>返回符合查询条件的结果集。如果使用了 <code>JSON</code> 关键字，那么结果将只会包括一栏名为 “json” 的列。具体请参考 <code>SELECT JSON</code>。</p>
<h4 id="select-clause"><code>&lt;select-clause&gt;</code></h4>
<p><code>&lt;select-clause&gt;</code> 决定了哪些列需要在结果集中被返回，其为逗号分隔的列表，或代表全部列的通配符（<code>*</code>）。</p>
<p>一个 <code>&lt;selector&gt;</code> 可以是一个列名，也可以是一个包含了一或多个  @@s 的 <code>&lt;function&gt;</code>。允许的函数与  <code>&lt;term&gt;</code>  相同，具体请参考函数相关章节。除了这些通用函数以外，还支持 <code>WRITETIME</code> 函数选择此栏被插入时的时间戳，类似地还有 <code>TTL</code> 函数对应其生存时间。</p>
<p>任何 <code>&lt;selector&gt;</code> 都可以使用 <code>AS</code> 关键字标注别名。请注意， <code>&lt;where-clause&gt;</code> 和 <code>&lt;order-by&gt;</code> 子句应该使用它们的原始名称而非它们的别名。</p>
<p><code>COUNT(1)</code>  是 <code>COUNT(*)</code>  的别名。</p>
<h4 id="where-clause"><code>&lt;where-clause&gt;</code></h4>
<p><code>&lt;where-clause&gt;</code> 指明了哪些行一定会被查询到。其由列上的关系组成，并且这些列为主键的一部分，或存在一个二级索引。</p>
<p>并非所有关系都允许在查询中使用。比如不支持在分区键上使用“不等于”关系（但是可以参考下文的 <code>TOKEN</code> 方法对分区键执行不等于查询）。以及，对于一个给定的分区键，其聚集键仅允许选择一组连续行的关系。比如对于以下表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> posts (
</span></span><span style="display:flex;"><span>    userid <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    blog_title <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    posted_at <span style="color:#8be9fd;font-style:italic">timestamp</span>,
</span></span><span style="display:flex;"><span>    entry_title <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    content <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    category <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span> (userid, blog_title, posted_at)
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>这一句查询是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> entry_title, content <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> userid<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;john doe&#39;</span> <span style="color:#ff79c6">AND</span> blog_title<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;John&#39;&#39;s Blog&#39;</span> <span style="color:#ff79c6">AND</span> posted_at <span style="color:#ff79c6">&gt;=</span> <span style="color:#f1fa8c">&#39;2012-01-01&#39;</span> <span style="color:#ff79c6">AND</span> posted_at <span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c">&#39;2012-01-31&#39;</span>
</span></span></code></pre></div><p>但以下这一句不可行，因为其没有选择一组连续的行（假设没有设置二级索引）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#6272a4">// Needs a blog_title to be set to select ranges of posted_at
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">SELECT</span> entry_title, content <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> userid<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;john doe&#39;</span> <span style="color:#ff79c6">AND</span> posted_at <span style="color:#ff79c6">&gt;=</span> <span style="color:#f1fa8c">&#39;2012-01-01&#39;</span> <span style="color:#ff79c6">AND</span> posted_at <span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c">&#39;2012-01-31&#39;</span>
</span></span></code></pre></div><p>在指定关系时，<code>TOKEN</code> 函数可以被用于分区键的查询。在这种情况下，将根据分区键的 token 而不是它们的值来进行选择。注意，键的 token 依赖于被使用的分区器，尤其是， RandomPartitioner 不会产生有意义的顺序。同时还要注意，排序分区器总是根据字节来进行 token 值的排序，所以即便分区键的值是 int 型，实际上却是<code>token(-1) &gt; token(0)</code>。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> <span style="color:#ff79c6">token</span>(userid) <span style="color:#ff79c6">&gt;</span> <span style="color:#ff79c6">token</span>(<span style="color:#f1fa8c">&#39;tom&#39;</span>) <span style="color:#ff79c6">AND</span> <span style="color:#ff79c6">token</span>(userid) <span style="color:#ff79c6">&lt;</span> <span style="color:#ff79c6">token</span>(<span style="color:#f1fa8c">&#39;bob&#39;</span>)
</span></span></code></pre></div><p>并且，<code>IN</code> 关系只允许使用在分区键的最后一列和完整主键的最后一列上。</p>
<p>可以对聚集键使用元组标识进行组合查询，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> userid<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;john doe&#39;</span> <span style="color:#ff79c6">AND</span> (blog_title, posted_at) <span style="color:#ff79c6">&gt;</span> (<span style="color:#f1fa8c">&#39;John&#39;&#39;s Blog&#39;</span>, <span style="color:#f1fa8c">&#39;2012-01-01&#39;</span>)
</span></span></code></pre></div><p>这会返回排序在 <code>blog_tile</code> = <code>John's Blog</code> 且  <code>posted_at</code>  = <code>2012-01-01</code> 之后的行。事实上，只要这些行的r <code>blog_title &gt; 'John''s Blog'</code>，即便其 <code>post_at &lt;= '2012-01-01'</code> ，结果依然会返回。如果不想出现这种结果，那应该使用以下这种：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> userid<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;john doe&#39;</span> <span style="color:#ff79c6">AND</span> blog_title <span style="color:#ff79c6">&gt;</span> <span style="color:#f1fa8c">&#39;John&#39;&#39;s Blog&#39;</span> <span style="color:#ff79c6">AND</span> posted_at <span style="color:#ff79c6">&gt;</span> <span style="color:#f1fa8c">&#39;2012-01-01&#39;</span>
</span></span></code></pre></div><p>元组标识同样可以用于聚集键的 <code>IN</code> 子句中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> posts <span style="color:#ff79c6">WHERE</span> userid<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;john doe&#39;</span> <span style="color:#ff79c6">AND</span> (blog_title, posted_at) <span style="color:#ff79c6">IN</span> ((<span style="color:#f1fa8c">&#39;John&#39;&#39;s Blog&#39;</span>, <span style="color:#f1fa8c">&#39;2012-01-01), (&#39;</span>Extreme Chess<span style="color:#f1fa8c">&#39;, &#39;</span><span style="color:#bd93f9">2014</span><span style="color:#ff79c6">-</span><span style="color:#bd93f9">06</span><span style="color:#ff79c6">-</span><span style="color:#bd93f9">01</span><span style="color:#f1fa8c">&#39;))
</span></span></span></code></pre></div><p><code>CONTAINS</code> 操作符只作用在集合类的列中。为 map 的情况下， <code>CONTAINS</code> 指向 map 的值；若想指向 map 的键，应该使用 <code>CONTAINS KEY</code> 。</p>
<h4 id="order-by"><code>&lt;order-by&gt;</code></h4>
<p><code>ORDER BY</code> 选项可以指定返回结果的顺序。<code>ASC</code> 升序，<code>DESC</code> 降序，默认升序。依赖于表的 <code>CLUSTERING ORDER</code> 配置，存在以下限制：</p>
<ul>
<li>如果表定义时没有任何特定的 <code>CLUSTERING ORDER</code> ，允许的排序是聚集键的顺序或其倒序。</li>
<li>否则，只允许  <code>CLUSTERING ORDER</code> 中设置的顺序或其倒序。</li>
</ul>
<h4 id="limit"><code>LIMIT</code></h4>
<p>限制一条 <code>SELECT</code> 语句返回的行数。</p>
<h4 id="allow-filtering"><code>ALLOW FILTERING</code></h4>
<p>默认情况下，CQL 只允许那些不会引起服务端 “filtering” 操作的查询，例如我们知道会在结果集中读取返回全部记录的查询。因为可以预测到这些 “non filtering” 查询的性能，其所消耗的时间将与所要返回的数据量成正比（可以使用 <code>LIMIT</code> 控制）。</p>
<p><code>ALLOW FILTERING</code> 选项将显式地允许（某些）需要 filtering 的查询。请注意，如上所述，使用 <code>ALLOW FILTERING</code>  可能会导致不可预测的性能状况，比如即使只是选择少数记录的查询，其性能也可能收到集群数据总量的影响。</p>
<p>举个例子，下面的表格包含了用户的出生年份（有二级索引）和居住国家：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> <span style="color:#ff79c6">users</span> (
</span></span><span style="display:flex;"><span>    username <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    firstname <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    lastname <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    birth_year <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    country <span style="color:#8be9fd;font-style:italic">text</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> <span style="color:#ff79c6">ON</span> <span style="color:#ff79c6">users</span>(birth_year);
</span></span></code></pre></div><p>以下这些查询是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> firstname, lastname <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> birth_year <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1981</span>;
</span></span></code></pre></div><p>Cassandra 保证这些查询的性能与返回的数据量成比例。实际上，如果没有1981年出生的用户，那么第二个查询的性能并不会依赖于数据库中存储的用户数据（至少不会是直接依赖。考虑到二级索引的实现，该查询可能仍然依赖于集群中的节点数量，而节点数量间接依赖于存储的数据量。）。当然，这两个查询实际上都可能返回非常大的结果集，但是都可以通过添加一个 <code>LIMIT</code> 参数来控制返回的数据量。</p>
<p>不过下面这种就会被拒绝执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> firstname, lastname <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> birth_year <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1981</span> <span style="color:#ff79c6">AND</span> country <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;FR&#39;</span>;
</span></span></code></pre></div><p>因为 Cassandra 不能保证它不会扫描大量数据，即使实际的结果量其实很小。一般来说，即使只有少数人真正来自法国，它依然会扫描所有1981年出生用户的索引条目。但如果你确实知道你在做什么，那么可以加上 <code>ALLOW FILTERING</code> 让查询变得合法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> firstname, lastname <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> birth_year <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1981</span> <span style="color:#ff79c6">AND</span> country <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;FR&#39;</span> <span style="color:#ff79c6">ALLOW</span> <span style="color:#ff79c6">FILTERING</span>;
</span></span></code></pre></div><h2 id="数据库角色权限控制">数据库角色/权限控制</h2>
<p>暂时接触不上，以后再补充。</p>
<h2 id="数据类型">数据类型</h2>
<p>CQL 支持丰富的类型来定义表中的列，其中包括集合类型和用户自定义类型（通过继承 Cassandra 提供。</p>
<pre tabindex="0"><code>&lt;type&gt; ::= &lt;native-type&gt;
         | &lt;collection-type&gt;
         | &lt;tuple-type&gt;
         | &lt;string&gt;       // 用于用户自定义类型，其 JAVA 类的全限定名

&lt;native-type&gt; ::= ascii
                | bigint
                | blob
                | boolean
                | counter
                | date
                | decimal
                | double
                | float
                | inet
                | int
                | smallint
                | text
                | time
                | timestamp
                | timeuuid
                | tinyint
                | uuid
                | varchar
                | varint

&lt;collection-type&gt; ::= list &#39;&lt;&#39; &lt;native-type&gt; &#39;&gt;&#39;
                    | set  &#39;&lt;&#39; &lt;native-type&gt; &#39;&gt;&#39;
                    | map  &#39;&lt;&#39; &lt;native-type&gt; &#39;,&#39; &lt;native-type&gt; &#39;&gt;&#39;
&lt;tuple-type&gt; ::= tuple &#39;&lt;&#39; &lt;type&gt; (&#39;,&#39; &lt;type&gt;)* &#39;&gt;&#39;
</code></pre><p>注意原始类型是关键词并且也是不区分大小写的。不过它们并不是保留字。</p>
<p>下表给出了原始类型的附加信息以及其支持的常量类型：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>constants supported</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ascii</code></td>
<td>strings</td>
<td>ASCII character string</td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>integers</td>
<td>64-bit signed long</td>
</tr>
<tr>
<td><code>blob</code></td>
<td>blobs</td>
<td>Arbitrary bytes (no validation)</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>booleans</td>
<td>true or false</td>
</tr>
<tr>
<td><code>counter</code></td>
<td>integers</td>
<td>Counter column (64-bit signed value). See <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#counters">Counters</a> for details</td>
</tr>
<tr>
<td><code>date</code></td>
<td>integers, strings</td>
<td>A date (with no corresponding time value). See <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#usingdates">Working with dates</a> below for more information.</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>integers, floats</td>
<td>Variable-precision decimal</td>
</tr>
<tr>
<td><code>double</code></td>
<td>integers</td>
<td>64-bit IEEE-754 floating point</td>
</tr>
<tr>
<td><code>float</code></td>
<td>integers, floats</td>
<td>32-bit IEEE-754 floating point</td>
</tr>
<tr>
<td><code>inet</code></td>
<td>strings</td>
<td>An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6). There is no <code>inet</code> constant, IP address should be inputed as strings</td>
</tr>
<tr>
<td><code>int</code></td>
<td>integers</td>
<td>32-bit signed int</td>
</tr>
<tr>
<td><code>smallint</code></td>
<td>integers</td>
<td>16-bit signed int</td>
</tr>
<tr>
<td><code>text</code></td>
<td>strings</td>
<td>UTF8 encoded string</td>
</tr>
<tr>
<td><code>time</code></td>
<td>integers, strings</td>
<td>A time with nanosecond precision. See <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#usingtime">Working with time</a> below for more information.</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>integers, strings</td>
<td>A timestamp. Strings constant are allow to input timestamps as dates, see <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#usingtimestamps">Working with timestamps</a> below for more information.</td>
</tr>
<tr>
<td><code>timeuuid</code></td>
<td>uuids</td>
<td>Type 1 UUID. This is generally used as a “conflict-free” timestamp. Also see the <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#timeuuidFun">functions on Timeuuid</a></td>
</tr>
<tr>
<td><code>tinyint</code></td>
<td>integers</td>
<td>8-bit signed int</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>uuids</td>
<td>Type 1 or type 4 UUID</td>
</tr>
<tr>
<td><code>varchar</code></td>
<td>strings</td>
<td>UTF8 encoded string</td>
</tr>
<tr>
<td><code>varint</code></td>
<td>integers</td>
<td>Arbitrary-precision integer</td>
</tr>
</tbody>
</table>
<h3 id="关于时间戳-timestamps">关于时间戳 timestamps</h3>
<p><code>timestamp</code> 类型由一个代表 January 1 1970 at 00:00:00 GMT. 以来经过的毫秒数的64位有符号整数编码。</p>
<p>时间戳可以直接使用长整数在 CQL 中使用，也可以使用以下 任意 ISO 8601 格式的字符串使用：</p>
<ul>
<li><code>2011-02-03 04:05+0000</code></li>
<li><code>2011-02-03 04:05:00+0000</code></li>
<li><code>2011-02-03 04:05:00.000+0000</code></li>
<li><code>2011-02-03T04:05+0000</code></li>
<li><code>2011-02-03T04:05:00+0000</code></li>
<li><code>2011-02-03T04:05:00.000+0000</code></li>
</ul>
<p>以上 <code>+0000</code> 用于指定时区，可以省略，此时使用的是 Cassandra 节点所配置的时区。</p>
<ul>
<li><code>2011-02-03 04:05</code></li>
<li><code>2011-02-03 04:05:00</code></li>
<li><code>2011-02-03 04:05:00.000</code></li>
<li><code>2011-02-03T04:05</code></li>
<li><code>2011-02-03T04:05:00</code></li>
<li><code>2011-02-03T04:05:00.000</code></li>
</ul>
<p>如果日期是唯一重要的部分，时间也可以省略，此时的时间将被设定为 <code>00:00:00</code>。</p>
<ul>
<li><code>2011-02-03</code></li>
<li><code>2011-02-03+0000</code></li>
</ul>
<h3 id="关于日期-dates">关于日期 dates</h3>
<p><code>date</code> 类型由一个32位无符号整数编码，代表 January 1st, 1970 以来的天数。</p>
<p>CQL 中日期可以使用一个无符号整数也可以使用以下格式的字符串：</p>
<ul>
<li><code>2014-01-01</code></li>
</ul>
<h3 id="关于时间-time">关于时间 time</h3>
<p><code>time</code> 类型由一个64位有符号整数编码，代表从半夜以来的纳秒数。</p>
<ul>
<li><code>08:12:54</code></li>
<li><code>08:12:54.123</code></li>
<li><code>08:12:54.123456</code></li>
<li><code>08:12:54.123456789</code></li>
</ul>
<h3 id="counters-计数器">Counters 计数器</h3>
<p><code>counter</code> 类型用于定义计数器列，由一个64位有符号整数编码，支持递增和递减两种操作（参照 <code>UPDATE</code>）。</p>
<p>计数器不能被直接赋值，在发生第一次递增或递减操作之前计数器不会存在，在发生第一次操作时其初始值会被当作是0。计数器列支持被删除，但存在一些限制。（具体待补充，跳转链接过期了）</p>
<p>计数器类型存在以下限制：</p>
<ul>
<li>不能被当作主键</li>
<li>一张包含计数器类型的表只能包含计数器。换句话说，主键以外的列要不全是计数器类型，要不全都不是计数器类型。</li>
</ul>
<h3 id="关于集合-collections">关于集合 collections</h3>
<h4 id="注意点">注意点</h4>
<p>集合主要用于存储、规范化相对小规模的数据。如果集合的数据量会无边界地增长，那么集合就不再合适了，应该使用包含聚集键的特定表。具体地说，集合存在以下限制：</p>
<ul>
<li>集合总是被完整地读取，读取一个集合在内部不会被分页</li>
<li>集合不能有多于 65535 个元素。虽然可以插入大于 65535 个元素，但无法读取超过 65535 的第一个元素（参考 <a href="https://issues.apache.org/jira/browse/CASSANDRA-5428">CASSANDRA-5428</a>）</li>
<li>对于 set 和 map 类型，插入操作在内部不会触发写前读（read-before-write），而 list 的一些操作会。因此推荐尽可能优先使用 list。</li>
</ul>
<h4 id="maps">Maps</h4>
<p><code>map</code> 是一组键值对，且键是唯一的。此外，map 在内部是按键排序的，并且总是按照这个顺序返回。创建 map 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> <span style="color:#ff79c6">users</span> (
</span></span><span style="display:flex;"><span>    id <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    given <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    surname <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    favs <span style="color:#8be9fd;font-style:italic">map</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">text</span>, <span style="color:#8be9fd;font-style:italic">text</span><span style="color:#ff79c6">&gt;</span>   <span style="color:#6272a4">// A map of text keys, and text values
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>)
</span></span></code></pre></div><p>写入 map 数据使用的是 JSON 式的语法。如果要使用 <code>INSERT</code> 写入一条数据，则将整个 map 指定为 json 风格的关联数组（注意，这种会替换掉整个 map）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#6272a4">// Inserting (or Updating)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> <span style="color:#ff79c6">users</span> (id, given, surname, favs)
</span></span><span style="display:flex;"><span>           <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;jsmith&#39;</span>, <span style="color:#f1fa8c">&#39;John&#39;</span>, <span style="color:#f1fa8c">&#39;Smith&#39;</span>, { <span style="color:#f1fa8c">&#39;fruit&#39;</span> : <span style="color:#f1fa8c">&#39;apple&#39;</span>, <span style="color:#f1fa8c">&#39;band&#39;</span> : <span style="color:#f1fa8c">&#39;Beatles&#39;</span> })
</span></span></code></pre></div><p>可以使用 <code>UPDATE</code> 更新 map 中的部分数据或添加新数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#6272a4">// Updating (or inserting)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">UPDATE</span> <span style="color:#ff79c6">users</span> <span style="color:#8be9fd;font-style:italic">SET</span> favs[<span style="color:#f1fa8c">&#39;author&#39;</span>] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;Ed Poe&#39;</span> <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;jsmith&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> <span style="color:#ff79c6">users</span> <span style="color:#8be9fd;font-style:italic">SET</span> favs <span style="color:#ff79c6">=</span> favs <span style="color:#ff79c6">+</span>  { <span style="color:#f1fa8c">&#39;movie&#39;</span> : <span style="color:#f1fa8c">&#39;Cassablanca&#39;</span> } <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;jsmith&#39;</span>
</span></span></code></pre></div><p><code>TTL</code> 可以用于 <code>INSERT</code> 和 <code>UPDATE</code>，但都只对新插入/更新的值有效。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#6272a4">// Updating (or inserting)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">UPDATE</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">USING</span> <span style="color:#ff79c6">TTL</span> <span style="color:#bd93f9">10</span> <span style="color:#8be9fd;font-style:italic">SET</span> favs[<span style="color:#f1fa8c">&#39;color&#39;</span>] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;green&#39;</span> <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;jsmith&#39;</span>
</span></span></code></pre></div><p>TTL 只作用在  <code>{ 'color' : 'green' }</code>  中，map 的其他值则不会受到影响。</p>
<p>删除一个 map 记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">DELETE</span> favs[<span style="color:#f1fa8c">&#39;author&#39;</span>] <span style="color:#ff79c6">FROM</span> <span style="color:#ff79c6">users</span> <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;jsmith&#39;</span>
</span></span></code></pre></div><h4 id="sets">Sets</h4>
<p>Set 是唯一值的类型化集合，由其中的值进行排序。创建一个 set：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> images (
</span></span><span style="display:flex;"><span>    name <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    owner <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">date</span> <span style="color:#8be9fd;font-style:italic">timestamp</span>,
</span></span><span style="display:flex;"><span>    tags <span style="color:#8be9fd;font-style:italic">set</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">text</span><span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>写入一个 set：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> images (name, owner, <span style="color:#8be9fd;font-style:italic">date</span>, tags)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;cat.jpg&#39;</span>, <span style="color:#f1fa8c">&#39;jsmith&#39;</span>, <span style="color:#f1fa8c">&#39;now&#39;</span>, { <span style="color:#f1fa8c">&#39;kitten&#39;</span>, <span style="color:#f1fa8c">&#39;cat&#39;</span>, <span style="color:#f1fa8c">&#39;pet&#39;</span> });
</span></span></code></pre></div><p>注意：<code>INSERT</code> 总是会替换掉整个 set。</p>
<p>可以通过 <code>UPDATE</code> 在现有 set 中添加/删除新 set 值来添加和删除集合的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> images <span style="color:#8be9fd;font-style:italic">SET</span> tags <span style="color:#ff79c6">=</span> tags <span style="color:#ff79c6">+</span> { <span style="color:#f1fa8c">&#39;cute&#39;</span>, <span style="color:#f1fa8c">&#39;cuddly&#39;</span> } <span style="color:#ff79c6">WHERE</span> name <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;cat.jpg&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> images <span style="color:#8be9fd;font-style:italic">SET</span> tags <span style="color:#ff79c6">=</span> tags <span style="color:#ff79c6">-</span> { <span style="color:#f1fa8c">&#39;lame&#39;</span> } <span style="color:#ff79c6">WHERE</span> name <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;cat.jpg&#39;</span>;
</span></span></code></pre></div><p>跟 map 一样，TTL 只作用在新插入/更新的值上。</p>
<h4 id="lists">Lists</h4>
<p>List 是一种非唯一值的类型化集合，其中元素按 list 中的位置排序。创建一个 list：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> plays (
</span></span><span style="display:flex;"><span>    id <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    game <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    players <span style="color:#8be9fd;font-style:italic">int</span>,
</span></span><span style="display:flex;"><span>    scores <span style="color:#8be9fd;font-style:italic">list</span><span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd;font-style:italic">int</span><span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>需要注意，list 存在一些限制和需要考虑的性能约束，比起 list 应尽可能优先使用 set。</p>
<p>写入 list ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> plays (id, game, players, scores)
</span></span><span style="display:flex;"><span>           <span style="color:#ff79c6">VALUES</span> (<span style="color:#f1fa8c">&#39;123-afde&#39;</span>, <span style="color:#f1fa8c">&#39;quake&#39;</span>, <span style="color:#bd93f9">3</span>, [<span style="color:#bd93f9">17</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">2</span>]);
</span></span></code></pre></div><p>注意：<code>INSERT</code> 总是会替换掉整个 list。</p>
<p>在已存在 list 的头部或尾部插入部分新的数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> plays <span style="color:#8be9fd;font-style:italic">SET</span> players <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>, scores <span style="color:#ff79c6">=</span> scores <span style="color:#ff79c6">+</span> [ <span style="color:#bd93f9">14</span>, <span style="color:#bd93f9">21</span> ] <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;123-afde&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> plays <span style="color:#8be9fd;font-style:italic">SET</span> players <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>, scores <span style="color:#ff79c6">=</span> [ <span style="color:#bd93f9">12</span> ] <span style="color:#ff79c6">+</span> scores <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;123-afde&#39;</span>;
</span></span></code></pre></div><p>注意：添加操作并非幂等的，因此如果采用失败重试的策略，有可能会往 list 中重复插入相同的值。</p>
<p>List 还提供了以下操作：根据元素在 list 中的位置设置、删除元素；删除列表中给定值的所有出现项。然而，与所有其他集合操作不同，这三种操作会在更新之前触发内部读取，导致性能通常较慢。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">UPDATE</span> plays <span style="color:#8be9fd;font-style:italic">SET</span> scores[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span> <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;123-afde&#39;</span>;                <span style="color:#6272a4">// sets the 2nd element of scores to 7 (raises an error is scores has less than 2 elements)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">DELETE</span> scores[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">FROM</span> plays <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;123-afde&#39;</span>;                   <span style="color:#6272a4">// deletes the 2nd element of scores (raises an error is scores has less than 2 elements)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">UPDATE</span> plays <span style="color:#8be9fd;font-style:italic">SET</span> scores <span style="color:#ff79c6">=</span> scores <span style="color:#ff79c6">-</span> [ <span style="color:#bd93f9">12</span>, <span style="color:#bd93f9">21</span> ] <span style="color:#ff79c6">WHERE</span> id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;123-afde&#39;</span>; <span style="color:#6272a4">// removes all occurrences of 12 and 21 from scores
</span></span></span></code></pre></div><p>与 map 相同，TTL 仅作用在新插入/更新的值上。</p>
<h2 id="函数">函数</h2>
<p>CQL3 区分了内置函数（也称本地函数 native functions）和用户自定义函数。CQL3 包括了以下几种本地函数：</p>
<h3 id="token">Token</h3>
<p><code>token</code> 函数用于计算一个给定分区键的 token 值。token 函数的准确签名取决于相关表和集群所使用的分区器。</p>
<p>token 的参数类型取决于分区键列的类型，返回类型取决于所使用的分区器：</p>
<ul>
<li>Murmur3Partitioner： <code>bigint</code></li>
<li>RandomPartitioner： <code>varint</code></li>
<li>ByteOrderedPartitioner： <code>blob</code></li>
</ul>
<p>举个例子，在使用默认 Murmur3Partitioner 分区器的集群中，如果表被定义为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> <span style="color:#ff79c6">users</span> (
</span></span><span style="display:flex;"><span>    userid <span style="color:#8be9fd;font-style:italic">text</span> <span style="color:#ff79c6">PRIMARY</span> <span style="color:#ff79c6">KEY</span>,
</span></span><span style="display:flex;"><span>    username <span style="color:#8be9fd;font-style:italic">text</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>token 函数则将接受单独一个 <code>text</code> 类型的入参，然后返回的类型为 <code>bigint</code>。</p>
<h3 id="uuid">Uuid</h3>
<p><code>uuid</code> 函数不需要入参，生成一个随机的 Version 4 UUID 用于 <code>INSERT</code> 或 <code>SET</code> 语句中。</p>
<h3 id="timeuuid-functions">Timeuuid functions</h3>
<h4 id="now"><code>now</code></h4>
<p><code>now</code> 函数不需要入参，会在执行语句时，在协调器节点上生成一个唯一的 timeuuid。注意虽然这个函数对于插入有用，但对于 <code>WHERE</code> 子句来说几乎毫无意义，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> myTable <span style="color:#ff79c6">WHERE</span> t <span style="color:#ff79c6">=</span> now()
</span></span></code></pre></div><p>在设计上这条查询永远不会返回任何结果，因为 <code>now()</code> 生成的值是唯一的。</p>
<h4 id="mintimeuuid-与-maxtimeuuid"><code>minTimeuuid</code> 与 <code>maxTimeuuid</code></h4>
<p><code>minTimeuuid</code>函数接收一个 <code>timestamp</code> 类型的入参 t （可以是长整数也可以是字符串），然后返回一个假造的 <code>timeuuid</code> ，对应此时间戳 t 可能的最小值 <code>timeuuid</code>。<code>maxTimeuuid</code> 则相反对应其最大值。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> myTable <span style="color:#ff79c6">WHERE</span> t <span style="color:#ff79c6">&gt;</span> maxTimeuuid(<span style="color:#f1fa8c">&#39;2013-01-01 00:05+0000&#39;</span>) <span style="color:#ff79c6">AND</span> t <span style="color:#ff79c6">&lt;</span> minTimeuuid(<span style="color:#f1fa8c">&#39;2013-02-02 10:00+0000&#39;</span>)
</span></span></code></pre></div><p>这条会选择所有  <code>timeuuid</code> 列 t 中严格地比 ‘2013-01-01 00:05+0000’  晚但比 ‘2013-02-02 10:00+0000’ 早的所有行。请注意， <code>t &gt;= maxTimeuuid('2013-01-01 00:05+0000')</code> 依然不会选择精确地在 ‘2013-01-01 00:05+0000’  时生成的 <code>timeuuid</code> ，本质上等同于  <code>t &gt; maxTimeuuid('2013-01-01 00:05+0000')</code>。</p>
<p>注意：我们称 <code>minTimeuuid</code> 和 <code>maxTimeuuid</code> 生成的值为假的 UUID，是因为它们并没有遵循 <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> 的基于时间的UUID生成进程。特别是这两个函数返回的值并不是唯一的，因此你应该只能使用这些函数进行类似上文例子的查询。不要在插入数据时使用这些函数。</p>
<h3 id="时间转换函数">时间转换函数</h3>
<p>有一系列函数用于转换  <code>timeuuid</code>、 <code>timestamp</code>  或 <code>date</code> 类型值为另一种  <code>native</code>  类型。</p>
<table>
<thead>
<tr>
<th>function name</th>
<th>input type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>toDate</code></td>
<td><code>timeuuid</code></td>
<td>Converts the <code>timeuuid</code> argument into a <code>date</code> type</td>
</tr>
<tr>
<td><code>toDate</code></td>
<td><code>timestamp</code></td>
<td>Converts the <code>timestamp</code> argument into a <code>date</code> type</td>
</tr>
<tr>
<td><code>toTimestamp</code></td>
<td><code>timeuuid</code></td>
<td>Converts the <code>timeuuid</code> argument into a <code>timestamp</code> type</td>
</tr>
<tr>
<td><code>toTimestamp</code></td>
<td><code>date</code></td>
<td>Converts the <code>date</code> argument into a <code>timestamp</code> type</td>
</tr>
<tr>
<td><code>toUnixTimestamp</code></td>
<td><code>timeuuid</code></td>
<td>Converts the <code>timeuuid</code> argument into a <code>bigInt</code> raw value</td>
</tr>
<tr>
<td><code>toUnixTimestamp</code></td>
<td><code>timestamp</code></td>
<td>Converts the <code>timestamp</code> argument into a <code>bigInt</code> raw value</td>
</tr>
<tr>
<td><code>toUnixTimestamp</code></td>
<td><code>date</code></td>
<td>Converts the <code>date</code> argument into a <code>bigInt</code> raw value</td>
</tr>
<tr>
<td><code>dateOf</code></td>
<td><code>timeuuid</code></td>
<td>Similar to <code>toTimestamp(timeuuid)</code> (DEPRECATED)</td>
</tr>
<tr>
<td><code>unixTimestampOf</code></td>
<td><code>timeuuid</code></td>
<td>Similar to <code>toUnixTimestamp(timeuuid)</code> (DEPRECATED)</td>
</tr>
</tbody>
</table>
<h3 id="blob转换函数">Blob转换函数</h3>
<p>对于所有 CQL3 所支持的本地类型（除了<code>blob</code>)，<code>typeAsBlob</code> 函数接受一个 <code>type</code> 参数并返回一个 <code>blob</code> 值。相反地，函数 <code>blobAsType</code> 接受一个 64 位 <code>blob</code> 参数，将其转换为一个 <code>bigint</code> 值。例如， <code>bigintAsBlob(3)</code> 返回 <code>0x0000000000000003</code> ， <code>blobAsBigint(0x0000000000000003)</code> 返回 <code>3</code>.</p>
<h2 id="聚合函数">聚合函数</h2>
<p>聚合函数从每一行中接受值，最终对整个集合返回一个值。如果是 <code>normal</code> 列、<code>scalar </code> 函数、 <code>UDT</code>  字段、 <code>writetime</code> 或 <code>ttl</code> 一起在聚合函数中被选择，其返回值都会变成其匹配的第一行的值。</p>
<p>CQL3区分了内置聚合（本地聚合）和用户自定义聚合，内置聚合函数有以下几种：</p>
<h3 id="count">Count</h3>
<p>用于计数返回的条数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">COUNT</span>(<span style="color:#ff79c6">*</span>) <span style="color:#ff79c6">FROM</span> plays;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">COUNT</span>(<span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">FROM</span> plays;
</span></span></code></pre></div><p>也可以用于计数给定列的非空值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">COUNT</span>(scores) <span style="color:#ff79c6">FROM</span> plays;
</span></span></code></pre></div><h3 id="max-和-min">Max 和 Min</h3>
<p>计算给定列在返回数据中的最大值、最小值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> MIN(players), MAX(players) <span style="color:#ff79c6">FROM</span> plays <span style="color:#ff79c6">WHERE</span> game <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;quake&#39;</span>;
</span></span></code></pre></div><h3 id="sum">Sum</h3>
<p>计算累加值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> SUM(players) <span style="color:#ff79c6">FROM</span> plays;
</span></span></code></pre></div><h3 id="avg">Avg</h3>
<p>计算平均值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CQL" data-lang="CQL"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> AVG(players) <span style="color:#ff79c6">FROM</span> plays;
</span></span></code></pre></div><h2 id="用户自定义函数聚合">用户自定义函数/聚合</h2>
<p>暂略。</p>
<h2 id="json-支持">JSON 支持</h2>
<p>Cassandra 2.2 开始引入了 <code>SELECT</code> 和 <code>INSERT</code> 语句的 JSON 支持。这种支持并没有从根本上改变 CQL API，只是提供了一种简便的方法去与 JSON 文档协作。</p>
<h3 id="select-json">SELECT JSON</h3>
<p><code>SELECT</code> 语句可以使用 <code>JSON </code> 关键字，以单 <code>JSON</code> 编码 map 的形式返回每一行数据。其他都与一般的 <code>SELECT</code> 语句表现相同。</p>
<p>结果中 map 的键名与查询时的栏名相同，比如  &ldquo;<code>SELECT JSON a, ttl(b) FROM ...</code>&rdquo;  会返回的 json 键名是 <code>a</code> 和 <code>ttl(b)</code>。不过这里存在一种特例，为了与 <code>INSERT JSON</code> 的表现保持同步，包含大写字符、区分大小写的列名将用双引号括起来。如  &ldquo;<code>SELECT JSON myColumn FROM ...</code>&rdquo;  会返回的键为  <code>&quot;\&quot;myColumn\&quot;&quot;</code> 。</p>
<p>map 的值会被表示为 JSON编码（参考下文）。</p>
<h3 id="insert-json">INSERT JSON</h3>
<p><code>INSERT</code> 语句可以使用 <code>JSON</code> 关键字将一个 JSON 编码 map 当作一行数据插入。JSON map 的格式通常应该与同一个表上的 <code>SELECT JSON</code> 语句返回的格式相同。对于区分大小写的列名，应使用双引号括住。比如：</p>
<pre tabindex="0"><code>INSERT INTO mytable JSON &#39;{&#34;\&#34;myKey\&#34;&#34;: 0, &#34;value&#34;: 0}&#39;
</code></pre><p>JSON map 中省略的任何列都将默认为 <code>NULL</code> 值（将导致一个墓碑被创建）。</p>
<h3 id="cassandra-数据类型的-json-编码">Cassandra 数据类型的 JSON 编码</h3>
<p>Cassandra 会尽可能地以原生 JSON 表现去展现或接收数据。Cassandra 对于所有单字段类型接受匹配 CQL 文本格式地字符串表现。比如浮点数、整型、UUID、date，都可以使用 CQL 文本字符串来表现。而对于复合类型，如 集合、元组、用户自定义类型等，则一定会被表现为原生 JSON 集合（map 或 list）或者 JSON 编码的集合字符串表现。</p>
<p>下表展示了 Cassandra 可以接受的 <code>INSERT JSON</code> 值（包括 <code>fromJson()</code> 的参数），以及 Cassandra 在使用 <code>SELECT JSON</code> 语句和 <code>fromJson()</code> 函数会返回的数据格式。（PS：后面那个应该是 <code>toJson()</code> 吧）</p>
<table>
<thead>
<tr>
<th>type</th>
<th>formats accepted</th>
<th>return format</th>
<th>notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ascii</code></td>
<td>string</td>
<td>string</td>
<td>Uses JSON’s <code>\u</code> character escape</td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>integer, string</td>
<td>integer</td>
<td>String must be valid 64 bit integer</td>
</tr>
<tr>
<td><code>blob</code></td>
<td>string</td>
<td>string</td>
<td>String should be 0x followed by an even number of hex digits</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>boolean, string</td>
<td>boolean</td>
<td>String must be “true” or &ldquo;false&rdquo;</td>
</tr>
<tr>
<td><code>date</code></td>
<td>string</td>
<td>string</td>
<td>Date in format <code>YYYY-MM-DD</code>, timezone UTC</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>integer, float, string</td>
<td>float</td>
<td>May exceed 32 or 64-bit IEEE-754 floating point precision in client-side decoder</td>
</tr>
<tr>
<td><code>double</code></td>
<td>integer, float, string</td>
<td>float</td>
<td>String must be valid integer or float</td>
</tr>
<tr>
<td><code>float</code></td>
<td>integer, float, string</td>
<td>float</td>
<td>String must be valid integer or float</td>
</tr>
<tr>
<td><code>inet</code></td>
<td>string</td>
<td>string</td>
<td>IPv4 or IPv6 address</td>
</tr>
<tr>
<td><code>int</code></td>
<td>integer, string</td>
<td>integer</td>
<td>String must be valid 32 bit integer</td>
</tr>
<tr>
<td><code>list</code></td>
<td>list, string</td>
<td>list</td>
<td>Uses JSON’s native list representation</td>
</tr>
<tr>
<td><code>map</code></td>
<td>map, string</td>
<td>map</td>
<td>Uses JSON’s native map representation</td>
</tr>
<tr>
<td><code>smallint</code></td>
<td>integer, string</td>
<td>integer</td>
<td>String must be valid 16 bit integer</td>
</tr>
<tr>
<td><code>set</code></td>
<td>list, string</td>
<td>list</td>
<td>Uses JSON’s native list representation</td>
</tr>
<tr>
<td><code>text</code></td>
<td>string</td>
<td>string</td>
<td>Uses JSON’s <code>\u</code> character escape</td>
</tr>
<tr>
<td><code>time</code></td>
<td>string</td>
<td>string</td>
<td>Time of day in format <code>HH-MM-SS[.fffffffff]</code></td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>integer, string</td>
<td>string</td>
<td>A timestamp. Strings constant are allow to input timestamps as dates, see <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#usingdates">Working with dates</a> below for more information. Datestamps with format <code>YYYY-MM-DD HH:MM:SS.SSS</code> are returned.</td>
</tr>
<tr>
<td><code>timeuuid</code></td>
<td>string</td>
<td>string</td>
<td>Type 1 UUID. See <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#constants">Constants</a> for the UUID format</td>
</tr>
<tr>
<td><code>tinyint</code></td>
<td>integer, string</td>
<td>integer</td>
<td>String must be valid 8 bit integer</td>
</tr>
<tr>
<td><code>tuple</code></td>
<td>list, string</td>
<td>list</td>
<td>Uses JSON’s native list representation</td>
</tr>
<tr>
<td><code>UDT</code></td>
<td>map, string</td>
<td>map</td>
<td>Uses JSON’s native map representation with field names as keys</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>string</td>
<td>string</td>
<td>See <a href="https://cassandra.apache.org/doc/old/CQL-3.0.html#constants">Constants</a> for the UUID format</td>
</tr>
<tr>
<td><code>varchar</code></td>
<td>string</td>
<td>string</td>
<td>Uses JSON’s <code>\u</code> character escape</td>
</tr>
<tr>
<td><code>varint</code></td>
<td>integer, string</td>
<td>integer</td>
<td>Variable length; may overflow 32 or 64 bit integers in client-side decoder</td>
</tr>
</tbody>
</table>
<h3 id="fromjson-函数">fromJson() 函数</h3>
<p><code>fromJson()</code> 与 <code>INSERT JSON</code> 类似，但只会返回一列的值。它只能用于 <code>INSERT</code> 的 <code>VALUES</code> 子句中，或者作为 <code>UPDATE</code>、 <code>DELETE</code> 或 <code>SELECT</code> 语句中的其中一列值。比如，它不能用于 <code>SELECT</code> 语句中的 <code>&lt;select-clause&gt;</code>子句。</p>
<h3 id="tojson-函数">toJson() 函数</h3>
<p><code>toJson()</code> 与 <code>SELECT JSON</code> 类似，但只会返回一列的值。其只应该被用于 <code>SELECT</code> 语句的 <code>&lt;select-clause&gt;</code>子句当中。</p>
<h2 id="附录acql-关键字">附录A：CQL 关键字</h2>
<p>CQL 的关键字区分保留和非保留的。保留关键字不可以作为标识符，但可以使用双引号括起来用作标识符。而非保留关键字只在特定的上下文中具有特定的含义，否则可以用作标识符。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>是否保留？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ADD</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>AGGREGATE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>ALL</code></td>
<td>no</td>
</tr>
<tr>
<td><code>ALLOW</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ALTER</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>AND</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>APPLY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>AS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>ASC</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ASCII</code></td>
<td>no</td>
</tr>
<tr>
<td><code>AUTHORIZE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>BATCH</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>BEGIN</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>BLOB</code></td>
<td>no</td>
</tr>
<tr>
<td><code>BOOLEAN</code></td>
<td>no</td>
</tr>
<tr>
<td><code>BY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>CALLED</code></td>
<td>no</td>
</tr>
<tr>
<td><code>CLUSTERING</code></td>
<td>no</td>
</tr>
<tr>
<td><code>COLUMNFAMILY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>COMPACT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>CONTAINS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>COUNT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>COUNTER</code></td>
<td>no</td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>CUSTOM</code></td>
<td>no</td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>DECIMAL</code></td>
<td>no</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>DESC</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>DESCRIBE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>DOUBLE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>DROP</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ENTRIES</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>EXECUTE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>EXISTS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FILTERING</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FINALFUNC</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FROM</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>FROZEN</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FULL</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>FUNCTION</code></td>
<td>no</td>
</tr>
<tr>
<td><code>FUNCTIONS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>GRANT</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>IF</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>IN</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>INDEX</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>INET</code></td>
<td>no</td>
</tr>
<tr>
<td><code>INFINITY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>INITCOND</code></td>
<td>no</td>
</tr>
<tr>
<td><code>INPUT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>INT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>INTO</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>JSON</code></td>
<td>no</td>
</tr>
<tr>
<td><code>KEY</code></td>
<td>no</td>
</tr>
<tr>
<td><code>KEYS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>KEYSPACE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>KEYSPACES</code></td>
<td>no</td>
</tr>
<tr>
<td><code>LANGUAGE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>LIMIT</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>LIST</code></td>
<td>no</td>
</tr>
<tr>
<td><code>LOGIN</code></td>
<td>no</td>
</tr>
<tr>
<td><code>MAP</code></td>
<td>no</td>
</tr>
<tr>
<td><code>MODIFY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>NAN</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>NOLOGIN</code></td>
<td>no</td>
</tr>
<tr>
<td><code>NORECURSIVE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>NOSUPERUSER</code></td>
<td>no</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>NULL</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>OF</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ON</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>OPTIONS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ORDER</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>PASSWORD</code></td>
<td>no</td>
</tr>
<tr>
<td><code>PERMISSION</code></td>
<td>no</td>
</tr>
<tr>
<td><code>PERMISSIONS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>PRIMARY</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>RENAME</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>REPLACE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>RETURNS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>REVOKE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>ROLE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>ROLES</code></td>
<td>no</td>
</tr>
<tr>
<td><code>SCHEMA</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>SELECT</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>SET</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>SFUNC</code></td>
<td>no</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>STATIC</code></td>
<td>no</td>
</tr>
<tr>
<td><code>STORAGE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>STYPE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>SUPERUSER</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TABLE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TIMEUUID</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TINYINT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TO</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>TOKEN</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>TRIGGER</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TRUNCATE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>TTL</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TUPLE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>TYPE</code></td>
<td>no</td>
</tr>
<tr>
<td><code>UNLOGGED</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>USE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>USER</code></td>
<td>no</td>
</tr>
<tr>
<td><code>USERS</code></td>
<td>no</td>
</tr>
<tr>
<td><code>USING</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>UUID</code></td>
<td>no</td>
</tr>
<tr>
<td><code>VALUES</code></td>
<td>no</td>
</tr>
<tr>
<td><code>VARCHAR</code></td>
<td>no</td>
</tr>
<tr>
<td><code>VARINT</code></td>
<td>no</td>
</tr>
<tr>
<td><code>WHERE</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>WITH</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>WRITETIME</code></td>
<td>no</td>
</tr>
</tbody>
</table>
<h2 id="附录bcql-保留类型">附录B：CQL 保留类型</h2>
<p>以下类型暂时还没有被 CQL 实际使用，但它们被保留以供未来可能的使用需要。用户自定义类型的名字不应该与保留类型相同。</p>
<table>
<thead>
<tr>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitstring</code></td>
</tr>
<tr>
<td><code>byte</code></td>
</tr>
<tr>
<td><code>complex</code></td>
</tr>
<tr>
<td><code>date</code></td>
</tr>
<tr>
<td><code>enum</code></td>
</tr>
<tr>
<td><code>interval</code></td>
</tr>
<tr>
<td><code>macaddr</code></td>
</tr>
</tbody>
</table>

                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2020-10-18-%E7%A7%8B%E5%AD%A3%E6%96%B0%E7%95%AA%E7%9A%84%E9%81%97%E6%86%BE/" data-toggle="tooltip" data-placement="top" title="秋季新番的遗憾">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/2021-02-10-2021%E5%86%AC%E5%AD%A3%E7%95%AA%E6%9D%82%E8%B0%88/" data-toggle="tooltip" data-placement="top" title="2021冬季番杂谈">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E4%BD%9C%E7%94%BB" title="作画">
                            作画
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E5%8A%A8%E7%94%BB" title="动画">
                            动画
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%8A%80%E6%9C%AF" title="技术">
                            技术
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%BC%94%E5%87%BA" title="演出">
                            演出
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%B5%84%E6%96%99" title="资料">
                            资料
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E9%87%8C%E7%A8%8B%E7%A2%91" title="里程碑">
                            里程碑
                        </a>
                        
                        
                        
                        <a href="/tags/%E9%9A%8F%E7%AC%94" title="随笔">
                            随笔
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:me#vonxxghost.xyz">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/VonXXGhost">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="V-ISLAND" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; V-ISLAND 2023
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





</body>
</html>
